<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesla Strip Controller</title>
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <style>
        :root {
            --color-bg: #050505;
            --color-surface: #0f0f0f;
            --color-panel: #181818;
            --color-border: #2b2b2b;
            --color-text: #f5f5f5;
            --color-muted: #b3b3b3;
            --color-input-bg: #161616;
            --color-input-border: #363636;
            --color-tab-inactive: #9b9b9b;
            --color-tab-hover: #242424;
            --color-table-header: #202020;
            --color-table-row: #161616;
            --color-table-text: #e0e0e0;
            --color-button-bg: #1f1f1f;
            --color-button-border: #3d3d3d;
            --color-shadow: rgba(0, 0, 0, 0.35);
            --carbon-base: #131313;
            --carbon-a: #151515;
            --carbon-b: #222222;
            --carbon-c: #1b1b1b;
            --carbon-d: #1d1d1d;
            --carbon-e: #1a1a1a;
            --carbon-f: #242424;
        }
        body.light-theme {
            --color-bg: #e9e9e4;
            --color-surface: #f6f5f1;
            --color-panel: #efeee9;
            --color-border: #cccac4;
            --color-text: #181818;
            --color-muted: #5a5a5a;
            --color-input-bg: #f8f6f1;
            --color-input-border: #c0beb8;
            --color-tab-inactive: #5f5f5f;
            --color-tab-hover: #dedcd6;
            --color-table-header: #e8e6df;
            --color-table-row: #fdfbf6;
            --color-table-text: #383838;
            --color-button-bg: #f7f6f2;
            --color-button-border: #c0beb8;
            --color-shadow: rgba(0, 0, 0, 0.15);
            --carbon-base: #ececec;
            --carbon-a: #eaeaea;
            --carbon-b: #dddddd;
            --carbon-c: #e4e4e4;
            --carbon-d: #e2e2e2;
            --carbon-e: #e5e5e5;
            --carbon-f: #dbdbdb;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background:
              linear-gradient(27deg, var(--carbon-a) 5px, transparent 5px) 0 5px,
              linear-gradient(207deg, var(--carbon-a) 5px, transparent 5px) 10px 0px,
              linear-gradient(27deg, var(--carbon-b) 5px, transparent 5px) 0px 10px,
              linear-gradient(207deg, var(--carbon-b) 5px, transparent 5px) 10px 5px,
              linear-gradient(90deg, var(--carbon-c) 10px, transparent 10px),
              linear-gradient(var(--carbon-d) 25%, var(--carbon-e) 25%, var(--carbon-e) 50%, transparent 50%, transparent 75%, var(--carbon-f) 75%, var(--carbon-f));
            background-color: var(--carbon-base);
            background-size: 20px 20px;
            min-height: 100vh;
            padding: 20px;
            color: var(--color-text);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--color-surface);
            border-radius: 4px;
            box-shadow: 0 4px 20px var(--color-shadow);
            overflow: visible;
            border: 1px solid var(--color-border);
        }
        .header {
            background: var(--color-panel);
            color: var(--color-text);
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #E82127;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        .header-logo {
            width: 64px;
            height: 64px;
            margin-right: 20px;
        }
        .header-logo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .header-content {
            flex: 1;
            text-align: left;
        }
        .header-controls {
            display: flex;
            gap: 20px;
            align-items: flex-end;
            text-align: left;
        }
        .ble-transport-control {
            min-width: 200px;
        }
        .ble-transport-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .ble-status-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 999px;
            border: 1px solid var(--color-input-border);
            background: var(--color-panel);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-muted);
            transition: border-color 0.3s, color 0.3s;
        }
        .ble-status-pill::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #E82127;
            transition: background 0.3s;
        }
        .ble-status-pill.connected {
            color: #6ae0a6;
            border-color: rgba(106, 224, 166, 0.4);
        }
        .ble-status-pill.connected::before {
            background: #2ecc71;
        }
        .ble-helper-text {
            font-size: 12px;
            color: var(--color-muted);
            margin-top: 4px;
        }
        .header-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 140px;
            text-align: left;
        }
        .header-control label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-muted);
        }
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
            font-weight: 300;
            letter-spacing: 2px;
        }
        .header p {
            font-size: 14px;
            opacity: 0.7;
            font-weight: 300;
        }
        .status-bar {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            background: var(--color-panel);
            border-bottom: 1px solid var(--color-border);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .status-item { text-align: center; font-size: 12px; }
        .status-value { font-weight: bold; font-size: 16px; margin-top: 5px; }
        .status-online { color: #10b981; }
        .status-offline { color: #E82127; }
        /* Tabs */
        .tabs {
            display: flex;
            background: var(--color-panel);
            border-bottom: 2px solid var(--color-border);
            overflow-x: auto;
            position: sticky;
            top: 62px;
            z-index: 90;
        }
        .tab {
            padding: 15px 20px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 14px;
            font-weight: 400;
            color: var(--color-muted);
            transition: all 0.3s;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
            flex: 0 0 auto;
        }
        .tab:hover {
            background: var(--color-border);
            color: var(--color-text);
        }
        .tab.active {
            color: var(--color-text);
            border-bottom: 3px solid #E82127;
            font-weight: 500;
        }
        .tab-content { display: none; padding: 30px; }
        .tab-content.active { display: block; }
        .section {
            margin-bottom: 30px;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--color-border);
        }
        .section:last-child { border-bottom: none; }
        .section-title {
            font-size: 18px;
            font-weight: 400;
            margin-bottom: 15px;
            color: var(--color-text);
            letter-spacing: 1px;
        }
        .section-subtitle {
            font-size: 14px;
            font-weight: 600;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #FF6B00;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        .control-group { margin-bottom: 20px; }
        .control-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 400;
            color: var(--color-text);
            font-size: 14px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: var(--color-input-border);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #E82127;
            cursor: pointer;
        }
        .slider-value {
            min-width: 50px;
            text-align: right;
            font-weight: 500;
            color: #E82127;
        }
        select, input[type="text"], input[type="password"], input[type="number"], input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--color-input-border);
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.3s;
            background: var(--color-panel);
            color: var(--color-text);
        }
        select:focus, input:focus {
            outline: none;
            border-color: #E82127;
        }
        .color-picker {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        input[type="color"] {
            width: 50px;
            height: 50px;
            border: 1px solid var(--color-input-border);
            border-radius: 4px;
            cursor: pointer;
            background: var(--color-panel);
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }
        .btn-primary {
            background: #E82127;
            color: var(--color-text);
            border: 1px solid #E82127;
        }
        .btn-primary:hover {
            background: #CC1D23;
            transform: translateY(-1px);
        }
        .btn-secondary {
            background: var(--color-border);
            color: var(--color-text);
            border: 1px solid var(--color-input-border);
        }
        .btn-secondary:hover {
            background: var(--color-input-border);
        }
        .btn-danger {
            background: #E82127;
            color: var(--color-text);
        }
        .btn-danger:hover {
            background: #CC1D23;
        }
        /* Toggle Switch for Event Simulation */
        .simulation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        .event-toggle-container {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: var(--color-panel);
            border-radius: 4px;
            border: 1px solid var(--color-input-border);
            transition: all 0.3s;
        }
        .event-toggle-container.active {
            background: rgba(232, 33, 39, 0.1);
            border-color: #E82127;
        }
        .event-toggle-label {
            flex: 1;
            font-size: 14px;
            color: var(--color-table-text);
            cursor: pointer;
        }
        .event-toggle-container.active .event-toggle-label {
            color: var(--color-text);
            font-weight: 500;
        }
        .event-toggle-container.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .event-toggle-container.disabled .event-toggle-label {
            cursor: not-allowed;
        }
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            cursor: pointer;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--color-input-border);
            transition: 0.3s;
            border-radius: 26px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: var(--color-text);
            transition: 0.3s;
            border-radius: 50%;
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: #E82127;
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
        .vehicle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .vehicle-item {
            padding: 15px;
            background: var(--color-panel);
            border-radius: 4px;
            border-left: 3px solid #E82127;
        }
        .vehicle-label { font-size: 12px; color: var(--color-muted); margin-bottom: 5px; }
        .vehicle-value { font-size: 16px; font-weight: 500; color: var(--color-text); }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: var(--color-panel);
            padding: 30px;
            border-radius: 4px;
            max-width: 400px;
            width: 90%;
            border: 1px solid var(--color-input-border);
        }
        .modal-content h3 {
            color: var(--color-text);
            font-weight: 400;
            letter-spacing: 1px;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .checkbox-container input[type="checkbox"] {
            width: auto;
            height: 20px;
        }
        /* Events Configuration Table */
        .events-table-wrapper {
            margin-top: 20px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            background: var(--color-panel);
        }
        .events-table-container {
            overflow-x: auto;
            overflow-y: auto;
            max-height: 60vh;
        }
        .events-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--color-panel);
            min-width: 900px;
        }
        .events-table th {
            padding: 12px 8px;
            text-align: left;
            background: var(--color-border);
            color: var(--color-text);
            font-weight: 500;
            font-size: 13px;
            border-bottom: 2px solid #E82127;
            position: sticky;
            top: 0;
            z-index: 5;
        }
        .events-table th:first-child,
        .events-table td:first-child {
            position: sticky;
            left: 0;
            background: var(--color-panel);
            z-index: 6;
        }
        .events-table th:first-child {
            background: var(--color-border);
            z-index: 7;
        }
        .events-table td {
            padding: 10px 8px;
            border-bottom: 1px solid var(--color-border);
            color: var(--color-table-text);
        }
        .events-table tr:hover {
            background: var(--color-border);
        }
        .events-table input[type="number"],
        .events-table select,
        .events-table input[type="color"] {
            padding: 6px 8px;
            font-size: 13px;
            width: 100%;
            background: var(--color-surface);
            border: 1px solid var(--color-input-border);
            color: var(--color-text);
        }
        .events-table input[type="color"] {
            padding: 2px;
            height: 30px;
            cursor: pointer;
        }
        .events-table input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .event-name-cell {
            font-weight: 500;
            color: var(--color-text);
        }
        /* Loading and notifications */
        .loading {
            text-align: center;
            padding: 20px;
            color: var(--color-muted);
        }
        .notification {
            position: fixed;
            top: 80px;
            right: 30px;
            min-width: 260px;
            padding: 12px 20px;
            border-radius: 6px;
            border-left: 3px solid;
            background: var(--color-panel);
            color: var(--color-text);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            z-index: 300;
        }
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        .notification.success {
            background: rgba(16, 185, 129, 0.1);
            border-color: #10b981;
            color: #10b981;
        }
        .notification.error {
            background: rgba(232, 33, 39, 0.5);
            border-color: #E82127;
            color: #FFFFFF;
        }
        .notification.info {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
            color: #3b82f6;
        }
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            .header-controls {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }
            .header-control {
                width: 100%;
                align-items: center;
                text-align: center;
            }
            .header-control select {
                width: 100%;
            }
            .tabs {
                flex-wrap: nowrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-logo">
                <img src="icon.svg" alt="Tesla Strip Logo">
            </div>
            <div class="header-content">
                <h1 data-i18n="app.title">TESLA STRIP CONTROLLER</h1>
                <p data-i18n="app.subtitle">Contrôle RGB synchronisé avec votre Tesla</p>
            </div>
            <div class="header-controls">
                <div class="header-control">
                    <label for="language-select" data-i18n="config.language">Langue</label>
                    <select id="language-select" onchange="setLanguage(this.value)">
                        <option value="fr" data-i18n="config.languageFrench">Français</option>
                        <option value="en" data-i18n="config.languageEnglish">English</option>
                    </select>
                </div>
                <div class="header-control">
                    <label for="theme-select" data-i18n="config.theme">Thème</label>
                    <select id="theme-select" onchange="setTheme(this.value)">
                        <option value="dark" data-i18n="config.themeDark">Mode sombre</option>
                        <option value="light" data-i18n="config.themeLight">Mode clair</option>
                    </select>
                </div>
                <div class="header-control ble-transport-control">
                    <label data-i18n="ble.title">Connexion BLE</label>
                    <div class="ble-transport-actions">
                        <button id="ble-connect-button" class="btn-secondary" onclick="toggleBleConnection()" data-i18n="ble.connect">Connexion</button>
                        <div id="ble-status-pill" class="ble-status-pill" data-i18n="ble.disconnected">Déconnecté</div>
                    </div>
                    <div id="ble-helper-text" class="ble-helper-text" hidden data-i18n="ble.notSupported">Web Bluetooth non supporté sur ce navigateur.</div>
                </div>
            </div>
        </div>
        <div id="ble-notification" class="notification"></div>
        <div class="status-bar">
            <div class="status-item">
                <div data-i18n="status.wifi">WiFi</div>
                <div class="status-value" id="wifi-status">...</div>
            </div>
            <div class="status-item">
                <div data-i18n="status.commander">Commander</div>
                <div class="status-value" id="commander-status">...</div>
            </div>
            <div class="status-item">
                <div data-i18n="status.vehicle">Véhicule</div>
                <div class="status-value" id="vehicle-status">...</div>
            </div>
            <div class="status-item">
                <div data-i18n="status.profile">Profil</div>
                <div class="status-value" id="profile-status">...</div>
            </div>
        </div>
        <!-- Tabs -->
        <div class="tabs">
          <button class="tab active" onclick="switchTab('vehicle')" data-i18n="tabs.vehicle">Véhicule</button>
          <button class="tab" onclick="switchTab('profiles')" data-i18n="tabs.profiles">Profils</button>
          <button class="tab" onclick="switchTab('events-config')" data-i18n="tabs.eventsConfig">Événements</button>
          <button class="tab" onclick="switchTab('simulation')" data-i18n="tabs.simulation">Simulation</button>
          <button class="tab" onclick="switchTab('commander')" data-i18n="tabs.commander">Commander</button>
          <button class="tab" onclick="switchTab('config')" data-i18n="tabs.config">Configuration</button>
          <button class="tab" onclick="switchTab('ota')" data-i18n="tabs.ota">Mise à Jour</button>
        </div>
        <!-- Tab: Véhicule -->
        <div id="vehicle-tab" class="tab-content active">
            <div class="section-title" data-i18n="vehicle.title">Données Véhicule</div>
            <!-- Section: État général -->
            <div class="section-subtitle" data-i18n="vehicle.generalState">État Général</div>
            <div class="vehicle-grid">
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.ignition">Contact</div>
                    <div class="vehicle-value" id="v-ignition">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.speed">Vitesse</div>
                    <div class="vehicle-value" id="v-speed">-- km/h</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.gear">Position de transmission</div>
                    <div class="vehicle-value" id="v-gear">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.brake">Frein</div>
                    <div class="vehicle-value" id="v-brake">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.locked">Verrouillé</div>
                    <div class="vehicle-value" id="v-locked">--</div>
                </div>
            </div>
            <!-- Section: Portes -->
            <div class="section-subtitle" data-i18n="vehicle.doorsTitle">Portes</div>
            <div class="vehicle-grid">
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.doorFL">AV Gauche</div>
                    <div class="vehicle-value" id="v-door-fl">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.doorFR">AV Droite</div>
                    <div class="vehicle-value" id="v-door-fr">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.doorRL">AR Gauche</div>
                    <div class="vehicle-value" id="v-door-rl">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.doorRR">AR Droite</div>
                    <div class="vehicle-value" id="v-door-rr">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.trunk">Coffre</div>
                    <div class="vehicle-value" id="v-trunk">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.frunk">Frunk</div>
                    <div class="vehicle-value" id="v-frunk">--</div>
                </div>
            </div>
            <!-- Section: Fenêtres -->
            <div class="section-subtitle" data-i18n="vehicle.windowsTitle">Fenêtres</div>
            <div class="vehicle-grid">
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.windowFL">AV Gauche</div>
                    <div class="vehicle-value" id="v-window-fl">--%</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.windowFR">AV Droite</div>
                    <div class="vehicle-value" id="v-window-fr">--%</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.windowRL">AR Gauche</div>
                    <div class="vehicle-value" id="v-window-rl">--%</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.windowRR">AR Droite</div>
                    <div class="vehicle-value" id="v-window-rr">--%</div>
                </div>
            </div>
            <!-- Section: Charge -->
            <div class="section-subtitle" data-i18n="vehicle.chargeTitle">Charge</div>
            <div class="vehicle-grid">
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.charging">En Charge</div>
                    <div class="vehicle-value" id="v-charging">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.chargePercent">Niveau</div>
                    <div class="vehicle-value" id="v-charge">--%</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.chargePower">Puissance</div>
                    <div class="vehicle-value" id="v-charge-power">-- kW</div>
                </div>
            </div>
            <!-- Section: Lumières -->
            <div class="section-subtitle" data-i18n="vehicle.lightsTitle">Lumières</div>
            <div class="vehicle-grid">
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.headlights">Phares</div>
                    <div class="vehicle-value" id="v-headlights">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.highBeams">Feux Route</div>
                    <div class="vehicle-value" id="v-high-beams">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.fogLights">Anti-brouillard</div>
                    <div class="vehicle-value" id="v-fog-lights">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.turnSignal">Clignotant</div>
                    <div class="vehicle-value" id="v-turn-signal">--</div>
                </div>
            </div>
            <!-- Section: Autres -->
            <div class="section-subtitle" data-i18n="vehicle.othersTitle">Autres</div>
            <div class="vehicle-grid">
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.battery12v">Batterie 12V</div>
                    <div class="vehicle-value" id="v-battery">-- V</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.odometer">Odomètre</div>
                    <div class="vehicle-value" id="v-odometer">-- km</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.nightMode">Mode Nuit</div>
                    <div class="vehicle-value" id="v-night">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.blindspotLeft">Angle Mort G</div>
                    <div class="vehicle-value" id="v-blindspot-left">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.blindspotRight">Angle Mort D</div>
                    <div class="vehicle-value" id="v-blindspot-right">--</div>
                </div>
            </div>
            <div class="section-subtitle" data-i18n="vehicle.sentryTitle">Mode Sentry</div>
            <div class="vehicle-grid">
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.sentryMode">État UI</div>
                    <div class="vehicle-value" id="v-sentry-mode">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.sentryRequest">Requête Autopilot</div>
                    <div class="vehicle-value" id="v-sentry-request">--</div>
                </div>
                <div class="vehicle-item">
                    <div class="vehicle-label" data-i18n="vehicle.sentryAlert">Alerte</div>
                    <div class="vehicle-value" id="v-sentry-alert">--</div>
                </div>
            </div>
        </div>
        <!-- Tab: Profils -->
        <div id="profiles-tab" class="tab-content">
            <div class="section-title" data-i18n="profiles.title">Gestion des Profils</div>
            <div id="profiles-notification" class="notification"></div>
            <div class="control-group">
                <label class="control-label" data-i18n="profiles.activeProfile">Profil Actif</label>
                <select id="profile-select">
                    <option value="-1" data-i18n="profiles.loading">Chargement...</option>
                </select>
            </div>
            <button class="btn-primary" onclick="activateProfile()" data-i18n="profiles.activate">Activer</button>
            <button class="btn-secondary" onclick="showNewProfileDialog()" data-i18n="profiles.new">Nouveau</button>
            <button class="btn-danger" onclick="deleteProfile()" data-i18n="profiles.delete">Supprimer</button>
            <button class="btn-secondary" onclick="exportProfile()" data-i18n="profiles.export">Exporter</button>
            <button class="btn-secondary" onclick="showImportDialog()" data-i18n="profiles.import">Importer</button>
            <div class="checkbox-container" style="margin-top: 20px;">
                <input type="checkbox" id="auto-night-mode" onchange="saveProfileSettings()">
                <label for="auto-night-mode" data-i18n="profiles.autoNightMode">Mode nuit automatique (basé sur CAN)</label>
            </div>
            <div class="control-group" style="margin-top: 10px;">
                <label class="control-label" data-i18n="profiles.nightBrightness">Luminosité Mode Nuit</label>
                <div class="slider-container">
                    <input type="range" id="night-brightness-slider" min="0" max="100" value="12" onchange="saveProfileSettings()">
                    <span class="slider-value" id="night-brightness-value">12%</span>
                </div>
            </div>
            <div class="section" style="margin-top: 30px;">
                <div class="section-title" style="font-size: 16px;" data-i18n="profiles.defaultEffect">Effet par Défaut</div>
                <p style="margin-bottom: 15px; color: var(--color-muted); font-size: 14px;" data-i18n="profiles.defaultEffectDesc">
                    Configurez l'effet affiché lorsqu'aucun événement CAN n'est actif.
                </p>
                <div class="control-group">
                    <label class="control-label" data-i18n="effects.effect">Effet</label>
                    <select id="default-effect-select" data-effect-options="true">
                            <!-- Will be populated dynamically -->
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label" data-i18n="effects.brightness">Luminosité</label>
                    <div class="slider-container">
                        <input type="range" id="default-brightness-slider" min="0" max="100" value="50">
                        <span class="slider-value" id="default-brightness-value">50%</span>
                    </div>
                </div>
                <div class="control-group">
                    <label class="control-label" data-i18n="effects.speed">Vitesse</label>
                    <div class="slider-container">
                        <input type="range" id="default-speed-slider" min="0" max="100" value="50">
                        <span class="slider-value" id="default-speed-value">50%</span>
                    </div>
                </div>
                <div class="control-group">
                    <label class="control-label" data-i18n="effects.color">Couleur</label>
                    <input type="color" id="default-color1" value="#ff0000">
                </div>
            </div>
        </div>
        <!-- Tab: Events Configuration -->
        <div id="events-config-tab" class="tab-content">
            <div class="section-title" data-i18n="eventsConfig.title">Configuration des Événements</div>
            <div id="events-notification" class="notification"></div>
            <div id="events-loading" class="loading" data-i18n="eventsConfig.loading">Chargement de la configuration...</div>
            <div id="events-content" style="display: none;">
                <p style="margin-bottom: 20px; color: var(--color-muted); font-size: 14px;" data-i18n="eventsConfig.description">
                    Configurez les effets lumineux pour chaque événement CAN détecté par le véhicule.
                </p>
                <div class="events-table-wrapper">
                    <div class="events-table-container">
                        <table class="events-table">
                            <thead>
                                <tr>
                                    <th data-i18n="eventsConfig.eventName">Événement</th>
                                    <th data-i18n="eventsConfig.action">Action</th>
                                    <th data-i18n="eventsConfig.profile">Profil</th>
                                    <th data-i18n="eventsConfig.effect">Effet</th>
                                    <th data-i18n="eventsConfig.brightness">Luminosité</th>
                                    <th data-i18n="eventsConfig.speed">Vitesse</th>
                                    <th data-i18n="eventsConfig.color">Couleur</th>
                                    <th data-i18n="eventsConfig.duration">Durée (ms)</th>
                                    <th data-i18n="eventsConfig.priority">Priorité</th>
                                    <th data-i18n="eventsConfig.enabled">Activé</th>
                                </tr>
                            </thead>
                            <tbody id="events-table-body">
                                <!-- Will be populated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>
                <button class="btn-secondary" onclick="loadEventsConfig()" data-i18n="eventsConfig.reload">Recharger</button>
            </div>
        </div>
        <!-- Tab: Commander -->
        <div id="commander-tab" class="tab-content">
            <div class="section-title" data-i18n="commander.title">Connexion Commander</div>
            <div id="commander-notification" class="notification"></div>
            <p style="margin-bottom: 20px; color: var(--color-muted);" data-i18n="commander.description">
                Connectez-vous au Tesla Commander pour recevoir les données CAN du véhicule.
            </p>
            <button class="btn-primary" onclick="connectCommander()" data-i18n="commander.connect">Connecter</button>
            <button class="btn-danger" onclick="disconnectCommander()" data-i18n="commander.disconnect">Déconnecter</button>
            <div class="section" style="margin-top: 30px;">
                <div class="section-title" data-i18n="commander.info">Informations</div>
                <p><strong>SSID Commander:</strong> S3XY_OBD</p>
                <p><strong>IP Commander:</strong> 192.168.4.1</p>
                <p><strong>Port:</strong> 1338</p>
            </div>
        </div>
        <!-- Tab: Simulation -->
        <div id="simulation-tab" class="tab-content">
            <div class="section-title" data-i18n="simulation.title">Simulation d'Événements CAN</div>
            <div id="simulation-notification" class="notification"></div>
            <p style="margin-bottom: 20px; color: var(--color-muted); font-size: 14px;" data-i18n="simulation.description">
                Testez les effets lumineux en simulant des événements CAN sans connexion au véhicule.
            </p>
            <div id="simulation-sections"></div>
            <div class="section">
                <div class="section-title" style="font-size: 16px;" data-i18n="simulation.nightMode">Mode Nuit</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                    <div class="event-toggle-container" id="event-toggle-nightmode">
                        <label class="event-toggle-label" for="toggle-nightmode" data-i18n="simulation.nightModeToggle">Mode Nuit</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-nightmode" onchange="toggleNightMode(this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
        <!-- Tab: Configuration -->
        <div id="config-tab" class="tab-content">
            <div class="section-title" data-i18n="config.title">Configuration Matérielle</div>
            <div id="config-notification" class="notification"></div>
            <p style="margin-bottom: 20px; color: var(--color-muted); font-size: 14px;" data-i18n="config.description">
                Configurez les paramètres matériels du contrôleur LED.
            </p>
            <div class="control-group">
                <label class="control-label" data-i18n="config.ledCount">Nombre de LEDs</label>
                <input type="number" id="led-count" value="" min="1" max="1000">
            </div>
            <div class="control-group">
                <label class="control-label" data-i18n="config.dataPin">Pin de Données</label>
                <input type="number" id="data-pin" value="" min="0" max="39">
            </div>
            <div class="checkbox-container" style="margin-top: 20px;">
                <input type="checkbox" id="strip-reverse">
                <label for="strip-reverse" data-i18n="config.stripReverse">Inverser le sens de la strip LED</label>
            </div>
            <button class="btn-primary" onclick="saveHardwareConfig()" data-i18n="config.save">Sauvegarder</button>
            <button class="btn-secondary" onclick="loadHardwareConfig()" data-i18n="config.reload">Recharger</button>
            <button class="btn-danger" style="margin-left: 10px;" onclick="restartDevice()" data-i18n="config.restartEsp">Redémarrer</button>
            <div class="section" style="margin-top: 40px; border-top: 2px solid #E82127; padding-top: 20px;">
                <div class="section-title" style="color: #E82127;" data-i18n="config.dangerZone">Zone Dangereuse</div>
                <p style="margin-bottom: 15px; color: var(--color-muted); font-size: 14px;" data-i18n="config.factoryResetWarning">
                    La réinitialisation usine supprimera TOUS les profils et configurations. Cette action est irréversible !
                </p>
                <button class="btn-danger" onclick="confirmFactoryReset()" data-i18n="config.factoryReset">Réinitialisation Usine</button>
            </div>
        </div>
        <!-- Tab: OTA -->
        <div id="ota-tab" class="tab-content">
            <div class="section-title" data-i18n="ota.title">Mise à Jour OTA</div>
            <div id="ota-notification" class="notification"></div>
            <div class="control-group">
                <label class="control-label" data-i18n="ota.currentVersion">Version Actuelle</label>
                <div style="padding: 12px; background: var(--color-panel); border-radius: 4px; font-weight: bold; border: 1px solid var(--color-input-border);" id="ota-version">
                    <span data-i18n="ota.loading">Chargement...</span>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label" data-i18n="ota.firmwareFile">Fichier Firmware (.bin)</label>
                <input type="file" id="firmware-file" accept=".bin">
            </div>
            <div id="ota-progress-container" style="display: none; margin-top: 15px;">
                <div style="background: var(--color-panel); border-radius: 4px; padding: 15px; border: 1px solid var(--color-input-border);">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span data-i18n="ota.progress">Progression</span>
                        <span id="ota-progress-percent" style="font-weight: bold;">0%</span>
                    </div>
                    <div style="background: var(--color-input-border); height: 8px; border-radius: 4px; overflow: hidden;">
                        <div id="ota-progress-bar" style="background: #E82127; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div id="ota-status-message" style="margin-top: 10px; font-size: 14px; color: var(--color-muted);"></div>
                    <div id="ota-reboot-countdown" style="margin-top: 6px; font-size: 14px; color: #FACC15; display: none;"></div>
                </div>
            </div>
            <button class="btn-primary" onclick="uploadFirmware()" id="ota-upload-btn" data-i18n="ota.upload">Téléverser</button>
            <button class="btn-secondary" onclick="restartDevice()" id="ota-restart-btn" style="display: none;" data-i18n="ota.restart">Redémarrer</button>
        </div>
    </div>
    <!-- Modal pour nouveau profil -->
    <div id="newProfileModal" class="modal">
        <div class="modal-content">
            <h3 style="margin-bottom: 20px;" data-i18n="profiles.newProfileTitle">Nouveau Profil</h3>
            <input type="text" id="new-profile-name" data-i18n-placeholder="profiles.profileName" placeholder="Nom du profil" style="margin-bottom: 20px;">
            <button class="btn-primary" onclick="createProfile()" data-i18n="profiles.create">Créer</button>
            <button class="btn-secondary" onclick="hideNewProfileDialog()" data-i18n="profiles.cancel">Annuler</button>
        </div>
    </div>
    <script>
        const API_BASE = '';
        // Translations
        const translations = {
            fr: {
                app: {
                    title: "TESLA STRIP CONTROLLER",
                    subtitle: "Contrôle RGB synchronisé avec votre Tesla"
                },
                status: {
                    wifi: "WiFi",
                    commander: "Commander",
                    vehicle: "Véhicule",
                    profile: "Profil",
                    connected: "Connecté",
                    disconnected: "Déconnecté",
                    active: "Actif",
                    inactive: "Inactif",
                    ap: "AP"
                },
                ble: {
                    title: "Connexion BLE",
                    connect: "Connexion",
                    connecting: "Connexion...",
                    disconnect: "Déconnexion",
                    connected: "Connecté",
                    disconnected: "Déconnecté",
                    statusUnsupported: "Non supporté",
                    notSupported: "Web Bluetooth non supporté sur ce navigateur.",
                    toastConnected: "Connexion BLE établie",
                    toastDisconnected: "Connexion BLE fermée",
                    toastError: "Erreur de communication BLE",
                    requestRejected: "Commande BLE refusée",
                    timeout: "Délai d'attente BLE dépassé"
                },
                tabs: {
                    effects: "Effets LED",
                    profiles: "Profils",
                    eventsConfig: "Événements",
                    canEvents: "Événements CAN",
                    config: "Configuration",
                    commander: "Commander",
                    vehicle: "Véhicule",
                    simulation: "Simulation",
                    ota: "Mise à Jour"
                },
                effects: {
                    title: "Configuration des Effets",
                    effect: "Effet",
                    brightness: "Luminosité",
                    speed: "Vitesse",
                    color: "Couleur",
                    apply: "Appliquer",
                    save: "Sauvegarder",
                    off: "Off",
                    solid: "Couleur Unie",
                    breathing: "Respiration",
                    rainbow: "Arc-en-ciel",
                    rainbowCycle: "Arc-en-ciel Cyclique",
                    theaterChase: "Theater Chase",
                    runningLights: "Running Lights",
                    twinkle: "Twinkle",
                    fire: "Feu",
                    scan: "Scan",
                    knightRider: "Knight Rider",
                    fade: "Fade",
                    strobe: "Strobe",
                    vehicleSync: "Sync Véhicule",
                    turnSignal: "Clignotant",
                    brakeLight: "Feu de Frein",
                    chargeStatus: "État de Charge"
                },
                profiles: {
                    title: "Gestion des Profils",
                    activeProfile: "Profil Actif",
                    loading: "Chargement...",
                    activate: "Activer",
                    new: "Nouveau",
                    delete: "Supprimer",
                    export: "Exporter",
                    import: "Importer",
                    autoNightMode: "Mode nuit automatique (basé sur CAN)",
                    nightBrightness: "Luminosité Mode Nuit",
                    defaultEffect: "Effet par Défaut",
                    defaultEffectDesc: "Configurez l'effet affiché lorsqu'aucun événement CAN n'est actif.",
                    saveDefault: "Sauvegarder Effet par Défaut",
                    newProfileTitle: "Nouveau Profil",
                    profileName: "Nom du profil",
                    create: "Créer",
                    cancel: "Annuler",
                    deleteConfirm: "Supprimer ce profil ?",
                    selectProfile: "Sélectionnez un profil",
                    exportSuccess: "Profil exporté avec succès",
                    exportError: "Erreur lors de l'export",
                    importSuccess: "Profil importé avec succès",
                    importError: "Erreur lors de l'import"
                },
                eventsConfig: {
                    title: "Configuration des Événements",
                    description: "Configurez les effets lumineux pour chaque événement CAN détecté par le véhicule.",
                    loading: "Chargement de la configuration...",
                    eventName: "Événement",
                    action: "Action",
                    profile: "Profil",
                    applyEffect: "Appliquer Effet",
                    switchProfile: "Changer Profil",
                    effect: "Effet",
                    brightness: "Luminosité",
                    speed: "Vitesse",
                    color: "Couleur",
                    duration: "Durée (ms)",
                    priority: "Priorité",
                    enabled: "Activé",
                    save: "Sauvegarder la Configuration",
                    reload: "Recharger",
                    saveSuccess: "Configuration sauvegardée avec succès",
                    saveError: "Erreur lors de la sauvegarde",
                    loadError: "Erreur lors du chargement"
                },
                canEvents: {
                    title: "Association Événements CAN",
                    event: "Événement",
                    effectToTrigger: "Effet à déclencher",
                    duration: "Durée (ms, 0 = infini)",
                    priority: "Priorité",
                    assign: "Assigner",
                    turnLeft: "Clignotant Gauche",
                    turnRight: "Clignotant Droit",
                    hazard: "Warning",
                    charging: "En Charge",
                    chargeComplete: "Charge Complète",
                    doorOpen: "Porte Ouverte",
                    doorClose: "Porte Fermée",
                    locked: "Verrouillé",
                    unlocked: "Déverrouillé",
                    brakeOn: "Frein Activé",
                    brakeOff: "Frein Relâché",
                    blindspotLeft: "Angle Mort Gauche",
                    blindspotRight: "Angle Mort Droit",
                    nightModeOn: "Mode Nuit Activé",
                    nightModeOff: "Mode Nuit Désactivé",
                    speedThreshold: "Seuil Vitesse Dépassé",
                    assignSuccess: "Effet assigné !"
                },
                config: {
                    title: "Configuration Matérielle",
                    description: "Configurez les paramètres matériels du contrôleur LED.",
                    ledCount: "Nombre de LEDs",
                    dataPin: "Pin de Données",
                    stripReverse: "Inverser le sens de la strip LED",
                    language: "Langue",
                    languageFrench: "Français",
                    languageEnglish: "Anglais",
                    theme: "Thème",
                    themeDark: "Mode sombre",
                    themeLight: "Mode clair",
                    save: "Sauvegarder",
                    reload: "Recharger",
                    saveSuccess: "Configuration sauvegardée",
                    saveError: "Erreur lors de la sauvegarde",
                    loadError: "Erreur lors du chargement",
                    dangerZone: "Zone Dangereuse",
                    factoryReset: "Réinitialisation Usine",
                    factoryResetWarning: "La réinitialisation usine supprimera TOUS les profils et configurations. Cette action est irréversible !",
                    factoryResetConfirm: "Êtes-vous VRAIMENT sûr de vouloir effacer toutes les configurations ? Cette action ne peut pas être annulée !",
                    factoryResetInProgress: "Réinitialisation en cours...",
                    factoryResetSuccess: "Réinitialisation réussie !",
                    factoryResetError: "Erreur lors de la réinitialisation",
                    deviceRestarting: "L'appareil va redémarrer dans quelques secondes..."
                },
                commander: {
                    title: "Connexion Commander",
                    description: "Connectez-vous au Tesla Commander pour recevoir les données CAN du véhicule.",
                    connect: "Connecter",
                    disconnect: "Déconnecter",
                    info: "Informations",
                    connecting: "Connexion au Commander..."
                },
                vehicle: {
                    title: "Données Véhicule",
                    generalState: "État Général",
                    ignition: "Contact",
                    speed: "Vitesse",
                    gear: "Position de transmission",
                    brake: "Frein",
                    locked: "Verrouillé",
                    unlocked: "Déverrouillé",
                    doorsTitle: "Portes",
                    doorFL: "AV Gauche",
                    doorFR: "AV Droite",
                    doorRL: "AR Gauche",
                    doorRR: "AR Droite",
                    trunk: "Coffre",
                    frunk: "Frunk",
                    windowsTitle: "Fenêtres",
                    windowFL: "AV Gauche",
                    windowFR: "AV Droite",
                    windowRL: "AR Gauche",
                    windowRR: "AR Droite",
                    chargeTitle: "Charge",
                    charging: "En Charge",
                    chargePercent: "Niveau",
                    chargePower: "Puissance",
                    lightsTitle: "Lumières",
                    headlights: "Phares",
                    highBeams: "Feux Route",
                    fogLights: "Anti-brouillard",
                    turnSignal: "Clignotant",
                    othersTitle: "Autres",
                    battery12v: "Batterie 12V",
                    odometer: "Odomètre",
                    nightMode: "Mode Nuit",
                    blindspotLeft: "Angle Mort G",
                    blindspotRight: "Angle Mort D",
                    open: "Ouvert",
                    closed: "Fermé",
                    none: "Aucun",
                    sentryTitle: "Mode Sentry",
                    sentryMode: "État UI",
                    sentryRequest: "Requête Autopilot",
                    sentryAlert: "Alerte",
                    sentryNominal: "Nominal",
                    sentrySuspend: "Suspendu"
                },
                simulation: {
                    title: "Simulation d'événements CAN",
                    description: "Testez les effets lumineux en simulant des événements CAN sans connexion au véhicule.",
                    turnSignals: "Clignotants",
                    left: "Gauche",
                    right: "Droite",
                    hazard: "Warning",
                    stop: "Arrêter",
                    charging: "Charge",
                    chargingNow: "En charge",
                    chargeComplete: "Charge complète",
                    chargingStarted: "Charge démarrée",
                    chargingStopped: "Charge arrêtée",
                    chargingHardware: "Connectique de charge",
                    cableConnected: "Câble connecté",
                    cableDisconnected: "Câble déconnecté",
                    portOpened: "Port de charge ouvert",
                    doors: "Portes",
                    doorOpen: "Porte ouverte",
                    doorClose: "Porte fermée",
                    lock: "Verrouillage",
                    locked: "Verrouillé",
                    unlocked: "Déverrouillé",
                    driving: "Conduite",
                    brakeOn: "Frein ON",
                    brakeOff: "Frein OFF",
                    speedThreshold: "Seuil Vitesse",
                    autopilot: "Autopilot",
                    autopilotEngaged: "Autopilot activé",
                    autopilotDisengaged: "Autopilot désactivé",
                    gear: "Transmission",
                    gearDrive: "Drive",
                    gearReverse: "Marche arrière",
                    gearPark: "Park",
                    blindspot: "Angle mort",
                    blindspotLeft: "Gauche",
                    blindspotRight: "Droite",
                    blindspotWarning: "Alerte angle mort",
                    sentry: "Mode Sentry",
                    sentryOn: "Sentry ON",
                    sentryOff: "Sentry OFF",
                    sentryAlert: "Alerte Sentry",
                    nightMode: "Mode Nuit",
                    nightModeToggle: "Mode Nuit",
                    nightModeOn: "Activer",
                    nightModeOff: "Désactiver",
                    sending: "Envoi de l'événement",
                    simulated: "Événement simulé",
                    error: "Erreur lors de la simulation",
                    stopping: "Arrêt de l'événement",
                    stopped: "Effet arrêté",
                    active: "actif",
                    disabledEvent: "Événement désactivé dans la configuration"
                },
                eventNames: {
                    TURN_LEFT: "Clignotant gauche",
                    TURN_RIGHT: "Clignotant droit",
                    TURN_HAZARD: "Feux de détresse",
                    CHARGING: "Charge en cours",
                    CHARGE_COMPLETE: "Charge terminée",
                    CHARGING_STARTED: "Charge démarrée",
                    CHARGING_STOPPED: "Charge arrêtée",
                    CHARGING_CABLE_CONNECTED: "Câble connecté",
                    CHARGING_CABLE_DISCONNECTED: "Câble déconnecté",
                    CHARGING_PORT_OPENED: "Port de charge ouvert",
                    DOOR_OPEN: "Porte ouverte",
                    DOOR_CLOSE: "Porte fermée",
                    LOCKED: "Véhicule verrouillé",
                    UNLOCKED: "Véhicule déverrouillé",
                    BRAKE_ON: "Frein activé",
                    BRAKE_OFF: "Frein relâché",
                    BLINDSPOT_LEFT: "Angle mort gauche",
                    BLINDSPOT_RIGHT: "Angle mort droit",
                    BLINDSPOT_WARNING: "Alerte angle mort",
                    NIGHT_MODE_ON: "Mode nuit activé",
                    NIGHT_MODE_OFF: "Mode nuit désactivé",
                    SPEED_THRESHOLD: "Seuil de vitesse atteint",
                    AUTOPILOT_ENGAGED: "Autopilot activé",
                    AUTOPILOT_DISENGAGED: "Autopilot désactivé",
                    GEAR_DRIVE: "Passage en Drive",
                    GEAR_REVERSE: "Marche arrière",
                    GEAR_PARK: "Mode Park",
                    SENTRY_MODE_ON: "Sentry activé",
                    SENTRY_MODE_OFF: "Sentry désactivé",
                    SENTRY_ALERT: "Alerte Sentry"
                },
                effectNames: {
                    OFF: "Aucun",
                    SOLID: "Couleur fixe",
                    BREATHING: "Respiration",
                    RAINBOW: "Arc-en-ciel",
                    RAINBOW_CYCLE: "Arc-en-ciel cyclique",
                    THEATER_CHASE: "Théâtre",
                    RUNNING_LIGHTS: "Lumières glissantes",
                    TWINKLE: "Scintillement",
                    FIRE: "Feu",
                    SCAN: "Balayage",
                    KNIGHT_RIDER: "Knight Rider",
                    FADE: "Fondu",
                    STROBE: "Stroboscope",
                    VEHICLE_SYNC: "Synchro véhicule",
                    TURN_SIGNAL: "Clignotant",
                    BRAKE_LIGHT: "Feu stop",
                    CHARGE_STATUS: "Statut de charge",
                    HAZARD: "Avertisseur",
                    BLINDSPOT_FLASH: "Flash angle mort"
                },
                ota: {
                    title: "Mise à Jour OTA",
                    currentVersion: "Version Actuelle",
                    loading: "Chargement...",
                    firmwareFile: "Fichier Firmware (.bin)",
                    progress: "Progression",
                    upload: "Téléverser",
                    restart: "Redémarrer",
                    uploading: "Téléversement en cours...",
                    success: "Mise à jour réussie ! Vous pouvez redémarrer.",
                error: "Erreur lors de la mise à jour",
                selectFile: "Veuillez sélectionner un fichier firmware",
                wrongExtension: "Le fichier doit avoir l'extension .bin",
                confirmUpdate: "Êtes-vous sûr de vouloir mettre à jour le firmware ? L'appareil redémarrera.",
                confirmRestart: "Redémarrer maintenant ?",
                restarting: "Redémarrage en cours... Reconnexion dans 10 secondes.",
                autoRestartIn: "Redémarrage automatique dans",
                states: {
                    idle: "En attente d'une mise à jour",
                    receiving: "Réception du firmware...",
                    writing: "Écriture du firmware...",
                    success: "Mise à jour terminée, redémarrage imminent",
                    error: "Erreur pendant la mise à jour"
                }
            },
            config: {
                restartEsp: "Redémarrer"
            }
        },
        en: {
                app: {
                    title: "TESLA STRIP CONTROLLER",
                    subtitle: "RGB Control Synchronized with your Tesla"
                },
                status: {
                    wifi: "WiFi",
                    commander: "Commander",
                    vehicle: "Vehicle",
                    profile: "Profile",
                    connected: "Connected",
                    disconnected: "Disconnected",
                    active: "Active",
                    inactive: "Inactive",
                    ap: "AP"
                },
                ble: {
                    title: "BLE Link",
                    connect: "Connect",
                    connecting: "Connecting...",
                    disconnect: "Disconnect",
                    connected: "Connected",
                    disconnected: "Disconnected",
                    statusUnsupported: "Unsupported",
                    notSupported: "Web Bluetooth is not supported on this browser.",
                    toastConnected: "BLE connected",
                    toastDisconnected: "BLE disconnected",
                    toastError: "BLE communication error",
                    requestRejected: "BLE request rejected",
                    timeout: "BLE request timed out"
                },
                tabs: {
                    effects: "LED Effects",
                    profiles: "Profiles",
                    eventsConfig: "Events",
                    canEvents: "CAN Events",
                    config: "Configuration",
                    commander: "Commander",
                    vehicle: "Vehicle",
                    simulation: "Simulation",
                    ota: "Update"
                },
                effects: {
                    title: "Effects Configuration",
                    effect: "Effect",
                    brightness: "Brightness",
                    speed: "Speed",
                    color: "Color",
                    apply: "Apply",
                    save: "Save",
                    off: "Off",
                    solid: "Solid Color",
                    breathing: "Breathing",
                    rainbow: "Rainbow",
                    rainbowCycle: "Rainbow Cycle",
                    theaterChase: "Theater Chase",
                    runningLights: "Running Lights",
                    twinkle: "Twinkle",
                    fire: "Fire",
                    scan: "Scan",
                    knightRider: "Knight Rider",
                    fade: "Fade",
                    strobe: "Strobe",
                    vehicleSync: "Vehicle Sync",
                    turnSignal: "Turn Signal",
                    brakeLight: "Brake Light",
                    chargeStatus: "Charge Status"
                },
                profiles: {
                    title: "Profile Management",
                    activeProfile: "Active Profile",
                    loading: "Loading...",
                    activate: "Activate",
                    new: "New",
                    delete: "Delete",
                    export: "Export",
                    import: "Import",
                    autoNightMode: "Automatic night mode (based on CAN)",
                    nightBrightness: "Night Mode Brightness",
                    defaultEffect: "Default Effect",
                    defaultEffectDesc: "Configure the effect displayed when no CAN event is active.",
                    saveDefault: "Save Default Effect",
                    newProfileTitle: "New Profile",
                    profileName: "Profile name",
                    create: "Create",
                    cancel: "Cancel",
                    deleteConfirm: "Delete this profile?",
                    selectProfile: "Select a profile",
                    exportSuccess: "Profile exported successfully",
                    exportError: "Error exporting profile",
                    importSuccess: "Profile imported successfully",
                    importError: "Error importing profile"
                },
                eventsConfig: {
                    title: "Events Configuration",
                    description: "Configure light effects for each CAN event detected by the vehicle.",
                    loading: "Loading configuration...",
                    eventName: "Event",
                    action: "Action",
                    profile: "Profile",
                    applyEffect: "Apply Effect",
                    switchProfile: "Switch Profile",
                    effect: "Effect",
                    brightness: "Brightness",
                    speed: "Speed",
                    color: "Color",
                    duration: "Duration (ms)",
                    priority: "Priority",
                    enabled: "Enabled",
                    save: "Save Configuration",
                    reload: "Reload",
                    saveSuccess: "Configuration saved successfully",
                    saveError: "Error saving configuration",
                    loadError: "Error loading configuration"
                },
                canEvents: {
                    title: "CAN Events Association",
                    event: "Event",
                    effectToTrigger: "Effect to trigger",
                    duration: "Duration (ms, 0 = infinite)",
                    priority: "Priority",
                    assign: "Assign",
                    turnLeft: "Turn Left",
                    turnRight: "Turn Right",
                    hazard: "Hazard",
                    charging: "Charging",
                    chargeComplete: "Charge Complete",
                    doorOpen: "Door Open",
                    doorClose: "Door Close",
                    locked: "Locked",
                    unlocked: "Unlocked",
                    brakeOn: "Brake On",
                    brakeOff: "Brake Off",
                    blindspotLeft: "Blindspot Left",
                    blindspotRight: "Blindspot Right",
                    nightModeOn: "Night Mode On",
                    nightModeOff: "Night Mode Off",
                    speedThreshold: "Speed Threshold",
                    assignSuccess: "Effect assigned!"
                },
                config: {
                    title: "Hardware Configuration",
                    description: "Configure hardware parameters for the LED controller.",
                    ledCount: "LED Count",
                    dataPin: "Data Pin",
                    stripReverse: "Reverse LED strip direction",
                    language: "Language",
                    languageFrench: "French",
                    languageEnglish: "English",
                    theme: "Theme",
                    themeDark: "Dark mode",
                    themeLight: "Light mode",
                    save: "Save",
                    reload: "Reload",
                    saveSuccess: "Configuration saved",
                    saveError: "Error saving configuration",
                    loadError: "Error loading configuration",
                    dangerZone: "Danger Zone",
                    factoryReset: "Factory Reset",
                    factoryResetWarning: "Factory reset will delete ALL profiles and configurations. This action is irreversible!",
                    factoryResetConfirm: "Are you REALLY sure you want to erase all configurations? This action cannot be undone!",
                    factoryResetInProgress: "Reset in progress...",
                    factoryResetSuccess: "Reset successful!",
                    factoryResetError: "Error during reset",
                    deviceRestarting: "The device will restart in a few seconds..."
                },
                commander: {
                    title: "Commander Connection",
                    description: "Connect to Tesla Commander to receive vehicle CAN data.",
                    connect: "Connect",
                    disconnect: "Disconnect",
                    info: "Information",
                    connecting: "Connecting to Commander..."
                },
                vehicle: {
                    title: "Vehicle Data",
                    generalState: "General State",
                    ignition: "Ignition",
                    speed: "Speed",
                    gear: "Gear",
                    brake: "Brake",
                    locked: "Locked",
                    unlocked: "Unlocked",
                    doorsTitle: "Doors",
                    doorFL: "Front Left",
                    doorFR: "Front Right",
                    doorRL: "Rear Left",
                    doorRR: "Rear Right",
                    trunk: "Trunk",
                    frunk: "Frunk",
                    windowsTitle: "Windows",
                    windowFL: "Front Left",
                    windowFR: "Front Right",
                    windowRL: "Rear Left",
                    windowRR: "Rear Right",
                    chargeTitle: "Charge",
                    charging: "Charging",
                    chargePercent: "Level",
                    chargePower: "Power",
                    lightsTitle: "Lights",
                    headlights: "Headlights",
                    highBeams: "High Beams",
                    fogLights: "Fog Lights",
                    turnSignal: "Turn Signal",
                    othersTitle: "Others",
                    battery12v: "12V Battery",
                    odometer: "Odometer",
                    nightMode: "Night Mode",
                    blindspotLeft: "Blindspot L",
                    blindspotRight: "Blindspot R",
                    open: "Open",
                    closed: "Closed",
                    none: "None",
                    sentryTitle: "Sentry Mode",
                    sentryMode: "UI State",
                    sentryRequest: "Autopilot Request",
                    sentryAlert: "Alert",
                    sentryNominal: "Nominal",
                    sentrySuspend: "Suspend"
                },
                simulation: {
                    title: "CAN Event Simulation",
                    description: "Test light effects by simulating CAN events without vehicle connection.",
                    turnSignals: "Turn Signals",
                    left: "Left",
                    right: "Right",
                    hazard: "Hazard",
                    stop: "Stop",
                    charging: "Charging",
                    chargingNow: "Charging",
                    chargeComplete: "Charge complete",
                    chargingStarted: "Charging started",
                    chargingStopped: "Charging stopped",
                    chargingHardware: "Charging hardware",
                    cableConnected: "Cable connected",
                    cableDisconnected: "Cable disconnected",
                    portOpened: "Charge port opened",
                    doors: "Doors",
                    doorOpen: "Door open",
                    doorClose: "Door close",
                    lock: "Lock",
                    locked: "Locked",
                    unlocked: "Unlocked",
                    driving: "Driving",
                    brakeOn: "Brake ON",
                    brakeOff: "Brake OFF",
                    speedThreshold: "Speed Threshold",
                    autopilot: "Autopilot",
                    autopilotEngaged: "Autopilot engaged",
                    autopilotDisengaged: "Autopilot disengaged",
                    gear: "Transmission",
                    gearDrive: "Drive",
                    gearReverse: "Reverse",
                    gearPark: "Park",
                    blindspot: "Blindspot",
                    blindspotLeft: "Left",
                    blindspotRight: "Right",
                    blindspotWarning: "Blindspot warning",
                    sentry: "Sentry Mode",
                    sentryOn: "Sentry ON",
                    sentryOff: "Sentry OFF",
                    sentryAlert: "Sentry Alert",
                    nightMode: "Night Mode",
                    nightModeToggle: "Night Mode",
                    nightModeOn: "Activate",
                    nightModeOff: "Deactivate",
                    sending: "Sending event",
                    simulated: "Event simulated",
                    error: "Simulation error",
                    stopping: "Stopping event",
                    stopped: "Effect stopped",
                    active: "active",
                    disabledEvent: "Event disabled in configuration"
                },
                eventNames: {
                    TURN_LEFT: "Turn signal left",
                    TURN_RIGHT: "Turn signal right",
                    TURN_HAZARD: "Hazard lights",
                    CHARGING: "Charging",
                    CHARGE_COMPLETE: "Charge complete",
                    CHARGING_STARTED: "Charging started",
                    CHARGING_STOPPED: "Charging stopped",
                    CHARGING_CABLE_CONNECTED: "Cable connected",
                    CHARGING_CABLE_DISCONNECTED: "Cable disconnected",
                    CHARGING_PORT_OPENED: "Charge port opened",
                    DOOR_OPEN: "Door open",
                    DOOR_CLOSE: "Door close",
                    LOCKED: "Vehicle locked",
                    UNLOCKED: "Vehicle unlocked",
                    BRAKE_ON: "Brake pressed",
                    BRAKE_OFF: "Brake released",
                    BLINDSPOT_LEFT: "Left blindspot",
                    BLINDSPOT_RIGHT: "Right blindspot",
                    BLINDSPOT_WARNING: "Blindspot warning",
                    NIGHT_MODE_ON: "Night mode on",
                    NIGHT_MODE_OFF: "Night mode off",
                    SPEED_THRESHOLD: "Speed threshold reached",
                    AUTOPILOT_ENGAGED: "Autopilot engaged",
                    AUTOPILOT_DISENGAGED: "Autopilot disengaged",
                    GEAR_DRIVE: "Gear Drive",
                    GEAR_REVERSE: "Gear Reverse",
                    GEAR_PARK: "Gear Park",
                    SENTRY_MODE_ON: "Sentry enabled",
                    SENTRY_MODE_OFF: "Sentry disabled",
                    SENTRY_ALERT: "Sentry alert"
                },
                effectNames: {
                    OFF: "Off",
                    SOLID: "Solid color",
                    BREATHING: "Breathing",
                    RAINBOW: "Rainbow",
                    RAINBOW_CYCLE: "Rainbow cycle",
                    THEATER_CHASE: "Theater chase",
                    RUNNING_LIGHTS: "Running lights",
                    TWINKLE: "Twinkle",
                    FIRE: "Fire",
                    SCAN: "Scanner",
                    KNIGHT_RIDER: "Knight Rider",
                    FADE: "Fade",
                    STROBE: "Strobe",
                    VEHICLE_SYNC: "Vehicle sync",
                    TURN_SIGNAL: "Turn signal",
                    BRAKE_LIGHT: "Brake light",
                    CHARGE_STATUS: "Charge status",
                    HAZARD: "Hazard",
                    BLINDSPOT_FLASH: "Blindspot flash"
                },
                ota: {
                    title: "OTA Update",
                    currentVersion: "Current Version",
                    loading: "Loading...",
                    firmwareFile: "Firmware File (.bin)",
                    progress: "Progress",
                    upload: "Upload",
                    restart: "Restart",
                    uploading: "Uploading...",
                    success: "Update successful! You can restart.",
                error: "Update error",
                selectFile: "Please select a firmware file",
                wrongExtension: "File must have .bin extension",
                confirmUpdate: "Are you sure you want to update the firmware? The device will restart.",
                confirmRestart: "Restart now?",
                restarting: "Restarting... Reconnecting in 10 seconds.",
                autoRestartIn: "Auto reboot in",
                states: {
                    idle: "Waiting for an update",
                    receiving: "Receiving firmware...",
                    writing: "Writing firmware to flash...",
                    success: "Update completed, restart pending",
                    error: "Update failed"
                }
            },
            config: {
                restartEsp: "Restart"
            }
        }
    };
        const OTA_STATE_KEYS = {
            0: 'idle',
            1: 'receiving',
            2: 'writing',
            3: 'success',
            4: 'error'
        };
        function getOtaStateKey(state) {
            if (state === undefined || state === null) {
                return 'idle';
            }
            const numericState = Number(state);
            return OTA_STATE_KEYS.hasOwnProperty(numericState) ? OTA_STATE_KEYS[numericState] : 'idle';
        }
        const BLE_CONFIG = {
            serviceUuid: '4fafc201-1fb5-459e-8fcc-c5c9c331914b',
            commandCharacteristicUuid: 'beb5483e-36e1-4688-b7f5-ea07361b26a8',
            responseCharacteristicUuid: '64a0990c-52eb-4c1b-aa30-ea826f4ba9dc',
            maxChunkSize: 180,
            responseTimeoutMs: 8000,
            deviceName: 'TESLA-STRIP'
        };
        const usingFileProtocol = window.location.protocol === 'file:';
        const FALLBACK_ORIGIN = (!usingFileProtocol && window.location.origin && window.location.origin !== 'null')
            ? window.location.origin
            : 'http://localhost';
        let bleTransportInstance = null;
        let wifiOnline = !usingFileProtocol && navigator.onLine;
        let apiConnectionReady = wifiOnline;
        let apiConnectionResolvers = [];
        let initialDataLoaded = false;
        let initialDataLoadPromise = null;
        let statusIntervalHandle = null;
        function isApiConnectionReady() {
            return wifiOnline || (bleTransportInstance && bleTransportInstance.isConnected());
        }
        function updateApiConnectionState() {
            const ready = isApiConnectionReady();
            if (ready && !apiConnectionReady) {
                apiConnectionReady = true;
                const resolvers = [...apiConnectionResolvers];
                apiConnectionResolvers = [];
                resolvers.forEach(resolve => resolve());
                if (!initialDataLoaded) {
                    scheduleInitialDataLoad();
                }
            } else if (!ready) {
                apiConnectionReady = false;
            }
        }
        function waitForApiConnection() {
            if (isApiConnectionReady()) {
                apiConnectionReady = true;
                return Promise.resolve();
            }
            return new Promise(resolve => {
                apiConnectionResolvers.push(resolve);
            });
        }
        function scheduleInitialDataLoad() {
            if (initialDataLoaded || initialDataLoadPromise) {
                return;
            }
            initialDataLoadPromise = (async () => {
                try {
                    await waitForApiConnection();
                    await loadInitialData();
                    initialDataLoaded = true;
                } catch (error) {
                    console.error('Initial data load failed:', error);
                    initialDataLoadPromise = null;
                }
            })();
        }
        window.addEventListener('online', () => {
            wifiOnline = !usingFileProtocol && navigator.onLine;
            updateApiConnectionState();
        });
        window.addEventListener('offline', () => {
            wifiOnline = false;
            updateApiConnectionState();
        });
        const bleTextEncoder = new TextEncoder();
        const bleTextDecoder = new TextDecoder();
        function normalizeUrl(url) {
            if (url instanceof URL) {
                return url;
            }
            try {
                if (typeof url === 'string' && !url.match(/^[a-zA-Z][a-zA-Z0-9+.-]*:/)) {
                    const trimmed = url.trim();
                    const withoutScheme = trimmed.replace(/^[a-zA-Z]+:\/*/i, '');
                    const withoutDrive = withoutScheme.replace(/^([a-zA-Z]:)/, '');
                    const normalized = withoutDrive.replace(/\\/g, '/');
                    const ensured = normalized.startsWith('/') ? normalized : '/' + normalized;
                    const finalUrl = new URL(FALLBACK_ORIGIN + ensured);
                    return finalUrl;
                }
                const parsed = new URL(url);
                const sanitizedPath = parsed.pathname.replace(/^\/?[a-zA-Z]:/, '').replace(/\\/g, '/');
                parsed.pathname = sanitizedPath.startsWith('/') ? sanitizedPath : '/' + sanitizedPath;
                const fallbackUrl = new URL(parsed.pathname + parsed.search, FALLBACK_ORIGIN);
                return fallbackUrl;
            } catch (e) {
                console.warn('[BLE] normalizeUrl failed for', url, e);
                return null;
            }
        }
        function pathLooksLikeApi(pathname) {
            if (!pathname) return false;
            const normalized = pathname.replace(/\\/g, '/');
            if (normalized === '/api' || normalized === 'api') return true;
            if (normalized.startsWith('/api/') || normalized.startsWith('api/')) return true;
            return normalized.includes('/api/');
        }
        function isApiRequestFromInput(input) {
            if (typeof input === 'string') {
                const normalized = normalizeUrl(input);
                return normalized ? pathLooksLikeApi(normalized.pathname) : false;
            } else if (input && typeof Request !== 'undefined' && input instanceof Request) {
                const normalized = normalizeUrl(input.url);
                return normalized ? pathLooksLikeApi(normalized.pathname) : false;
            }
            return false;
        }
        function isApiRequest(url, originalInput) {
            if (typeof originalInput !== 'undefined' && isApiRequestFromInput(originalInput)) {
                return true;
            }
            return isApiRequestFromInput(url);
        }
        class BleTransport {
            constructor() {
                this.device = null;
                this.server = null;
                this.commandCharacteristic = null;
                this.responseCharacteristic = null;
                this.responseBuffer = '';
                this.pending = null;
                this.listeners = new Set();
                this.status = this.isSupported() ? 'disconnected' : 'unsupported';
                this.boundDeviceDisconnect = this.handleDeviceDisconnected.bind(this);
                this.boundNotificationHandler = this.handleNotification.bind(this);
                this.requestQueue = Promise.resolve();
            }
            async requestDevice(forceNew = false) {
                if (!forceNew && this.device) {
                    return this.device;
                }
                const filters = [{ services: [BLE_CONFIG.serviceUuid] }];
                if (BLE_CONFIG.deviceName) {
                    filters.push({ name: BLE_CONFIG.deviceName });
                    filters.push({ namePrefix: BLE_CONFIG.deviceName });
                }
                const device = await navigator.bluetooth.requestDevice({
                    filters,
                    optionalServices: [BLE_CONFIG.serviceUuid]
                });
                if (this.device && this.device !== device) {
                    try {
                        this.device.removeEventListener('gattserverdisconnected', this.boundDeviceDisconnect);
                    } catch (e) {}
                }
                this.device = device;
                this.device.addEventListener('gattserverdisconnected', this.boundDeviceDisconnect);
                return device;
            }
            async ensureGattConnection(device, forceReconnect = false) {
                if (!device || !device.gatt) {
                    throw new Error('GATT server unavailable');
                }
                let server = device.gatt;
                if (forceReconnect && typeof server.disconnect === 'function' && server.connected) {
                    try {
                        server.disconnect();
                    } catch (e) {}
                }
                if (!server.connected) {
                    server = await server.connect();
                }
                this.server = server;
                return server;
            }
            isSupported() {
                return !!(navigator.bluetooth && navigator.bluetooth.requestDevice);
            }
            getStatus() {
                return this.status;
            }
            setStatus(status) {
                if (this.status === status) {
                    return;
                }
                this.status = status;
                this.listeners.forEach(listener => {
                    try {
                        listener(status);
                    } catch (e) {
                        console.warn('BLE status listener error', e);
                    }
                });
            }
            onStatusChange(cb) {
                if (typeof cb === 'function') {
                    this.listeners.add(cb);
                }
            }
            offStatusChange(cb) {
                if (cb && this.listeners.has(cb)) {
                    this.listeners.delete(cb);
                }
            }
            isConnected() {
                return this.status === 'connected';
            }
            shouldUseBle() {
                return this.isConnected();
            }
            async connect() {
                if (!this.isSupported()) {
                    throw new Error(t('ble.notSupported'));
                }
                if (this.isConnected() || this.status === 'connecting') {
                    return;
                }
                this.setStatus('connecting');
                try {
                    const device = await this.requestDevice();
                    let server = await this.ensureGattConnection(device);
                    let service;
                    try {
                        service = await server.getPrimaryService(BLE_CONFIG.serviceUuid);
                    } catch (error) {
                        if (error && error.name === 'NetworkError') {
                            server = await this.ensureGattConnection(device, true);
                            service = await server.getPrimaryService(BLE_CONFIG.serviceUuid);
                        } else {
                            throw error;
                        }
                    }
                    this.commandCharacteristic = await service.getCharacteristic(BLE_CONFIG.commandCharacteristicUuid);
                    this.responseCharacteristic = await service.getCharacteristic(BLE_CONFIG.responseCharacteristicUuid);
                    await this.responseCharacteristic.startNotifications();
                    this.responseCharacteristic.addEventListener('characteristicvaluechanged', this.boundNotificationHandler);
                    this.setStatus('connected');
                } catch (error) {
                    console.error('BLE connect error', error);
                    this.teardown();
                    this.setStatus(this.isSupported() ? 'disconnected' : 'unsupported');
                    throw error;
                }
            }
            async disconnect() {
                if (this.device) {
                    try {
                        this.device.removeEventListener('gattserverdisconnected', this.boundDeviceDisconnect);
                    } catch (e) {}
                }
                if (this.device && this.device.gatt && this.device.gatt.connected) {
                    try {
                        this.device.gatt.disconnect();
                    } catch (e) {}
                }
                this.teardown();
                this.setStatus(this.isSupported() ? 'disconnected' : 'unsupported');
            }
            handleDeviceDisconnected() {
                this.teardown();
                this.setStatus(this.isSupported() ? 'disconnected' : 'unsupported');
            }
            teardown() {
                if (this.responseCharacteristic) {
                    try {
                        this.responseCharacteristic.removeEventListener('characteristicvaluechanged', this.boundNotificationHandler);
                    } catch (e) {}
                }
                if (this.device) {
                    try {
                        this.device.removeEventListener('gattserverdisconnected', this.boundDeviceDisconnect);
                    } catch (e) {}
                }
                this.server = null;
                this.commandCharacteristic = null;
                this.responseCharacteristic = null;
                this.responseBuffer = '';
                this.device = null;
                if (this.pending && this.pending.reject) {
                    this.pending.reject(new Error(t('ble.disconnected')));
                }
                this.pending = null;
            }
            async sendRequest(message) {
                if (!this.commandCharacteristic) {
                    throw new Error(t('ble.disconnected'));
                }
                if (this.pending) {
                    throw new Error(t('ble.requestRejected'));
                }
                const framed = JSON.stringify(message) + '\n';
                const encoded = bleTextEncoder.encode(framed);
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        if (this.pending && this.pending.reject) {
                            this.pending.reject(new Error(t('ble.timeout')));
                        }
                    }, BLE_CONFIG.responseTimeoutMs);
                    this.pending = {
                        resolve: (response) => {
                            clearTimeout(timeoutId);
                            this.pending = null;
                            resolve(response);
                        },
                        reject: (err) => {
                            clearTimeout(timeoutId);
                            this.pending = null;
                            reject(err);
                        }
                    };
                    this.writeChunks(encoded).catch(error => {
                        if (this.pending && this.pending.reject) {
                            this.pending.reject(error);
                        } else {
                            reject(error);
                        }
                    });
                });
            }
            async writeChunks(encoded) {
                const chunkSize = BLE_CONFIG.maxChunkSize;
                for (let offset = 0; offset < encoded.length; offset += chunkSize) {
                    const chunk = encoded.slice(offset, Math.min(offset + chunkSize, encoded.length));
                    await this.commandCharacteristic.writeValueWithResponse(chunk);
                }
            }
            handleNotification(event) {
                const value = event.target.value;
                this.responseBuffer += bleTextDecoder.decode(value);
                let newlineIndex;
                while ((newlineIndex = this.responseBuffer.indexOf('\n')) !== -1) {
                    const message = this.responseBuffer.slice(0, newlineIndex).trim();
                    this.responseBuffer = this.responseBuffer.slice(newlineIndex + 1);
                    if (!message) {
                        continue;
                    }
                    let parsed;
                    try {
                        parsed = JSON.parse(message);
                    } catch (e) {
                        console.warn('Invalid BLE payload', message);
                        continue;
                    }
                    if (this.pending && this.pending.resolve) {
                        this.pending.resolve(parsed);
                    }
                }
            }
            enqueueRequest(taskFn) {
                const next = this.requestQueue.then(() => taskFn()).then(async (result) => {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    return result;
                });
                this.requestQueue = next.catch(() => {});
                return next;
            }
        }
        const bleTransport = new BleTransport();
        bleTransportInstance = bleTransport;
        updateApiConnectionState();
        const nativeFetch = window.fetch.bind(window);
        function shouldUseBleForRequest(url, isApiCallOverride) {
            if (!bleTransport.shouldUseBle()) {
                return false;
            }
            if (typeof isApiCallOverride === 'boolean') {
                return isApiCallOverride;
            }
            return isApiRequest(url);
        }
        window.fetch = async function(input, init = {}) {
            const request = new Request(input, init);
            const isApiCall = isApiRequest(request.url, input);
            if (isApiCall) {
                await waitForApiConnection();
            }
            if (!shouldUseBleForRequest(request.url, isApiCall)) {
                return nativeFetch(request);
            }
            const headers = {};
            request.headers.forEach((value, key) => {
                headers[key] = value;
            });
            let bodyText = undefined;
            const method = (request.method || 'GET').toUpperCase();
            if (method !== 'GET' && method !== 'HEAD') {
                try {
                    bodyText = await request.clone().text();
                } catch (e) {
                    bodyText = undefined;
                }
            }
            const urlObj = normalizeUrl(request.url);
            let requestPath;
            if (urlObj) {
                const normalizedPath = urlObj.pathname.replace(/\\/g, '/');
                requestPath = normalizedPath + urlObj.search;
            } else if (typeof request.url === 'string') {
                const trimmed = request.url.trim();
                const withoutScheme = trimmed.replace(/^[a-zA-Z]+:\/*/i, '');
                const withoutDrive = withoutScheme.replace(/^([a-zA-Z]:)/, '');
                const sanitized = withoutDrive.replace(/\\/g, '/');
                requestPath = sanitized.startsWith('/') ? sanitized : '/' + sanitized;
            } else {
                requestPath = '/';
            }
            try {
                const bleResponse = await bleTransport.enqueueRequest(() => bleTransport.sendRequest({
                    method,
                    path: requestPath,
                    headers,
                    body: bodyText
                }));
                const responseHeaders = new Headers(bleResponse.headers || { 'Content-Type': 'application/json' });
                return new Response(bleResponse.body || '', {
                    status: bleResponse.status || 200,
                    statusText: bleResponse.statusText || 'OK',
                    headers: responseHeaders
                });
            } catch (error) {
                console.error('BLE fetch error', error);
                throw error;
            }
        };
        let lastBleStatus = bleTransport.getStatus();
        bleTransport.onStatusChange((status) => {
            updateBleUiState();
            if (status === 'connected') {
                showNotification('ble-notification', t('ble.toastConnected'), 'success');
                updateApiConnectionState();
            } else if (status === 'disconnected' && lastBleStatus === 'connected') {
                showNotification('ble-notification', t('ble.toastDisconnected'), 'info');
                updateApiConnectionState();
            } else if (status === 'connecting') {
                updateApiConnectionState();
            }
            lastBleStatus = status;
        });
        const simulationSections = [
            {
                titleKey: 'simulation.turnSignals',
                events: [
                    { id: 'TURN_LEFT', labelKey: 'simulation.left' },
                    { id: 'TURN_RIGHT', labelKey: 'simulation.right' },
                    { id: 'TURN_HAZARD', labelKey: 'simulation.hazard' }
                ]
            },
            {
                titleKey: 'simulation.charging',
                events: [
                    { id: 'CHARGING', labelKey: 'simulation.chargingNow' },
                    { id: 'CHARGE_COMPLETE', labelKey: 'simulation.chargeComplete' },
                    { id: 'CHARGING_STARTED', labelKey: 'simulation.chargingStarted' },
                    { id: 'CHARGING_STOPPED', labelKey: 'simulation.chargingStopped' }
                ]
            },
            {
                titleKey: 'simulation.chargingHardware',
                events: [
                    { id: 'CHARGING_CABLE_CONNECTED', labelKey: 'simulation.cableConnected' },
                    { id: 'CHARGING_CABLE_DISCONNECTED', labelKey: 'simulation.cableDisconnected' },
                    { id: 'CHARGING_PORT_OPENED', labelKey: 'simulation.portOpened' }
                ]
            },
            {
                titleKey: 'simulation.doors',
                events: [
                    { id: 'DOOR_OPEN', labelKey: 'simulation.doorOpen' },
                    { id: 'DOOR_CLOSE', labelKey: 'simulation.doorClose' }
                ]
            },
            {
                titleKey: 'simulation.lock',
                events: [
                    { id: 'LOCKED', labelKey: 'simulation.locked' },
                    { id: 'UNLOCKED', labelKey: 'simulation.unlocked' }
                ]
            },
            {
                titleKey: 'simulation.driving',
                events: [
                    { id: 'BRAKE_ON', labelKey: 'simulation.brakeOn' },
                    { id: 'BRAKE_OFF', labelKey: 'simulation.brakeOff' },
                    { id: 'SPEED_THRESHOLD', labelKey: 'simulation.speedThreshold' }
                ]
            },
            {
                titleKey: 'simulation.autopilot',
                events: [
                    { id: 'AUTOPILOT_ENGAGED', labelKey: 'simulation.autopilotEngaged' },
                    { id: 'AUTOPILOT_DISENGAGED', labelKey: 'simulation.autopilotDisengaged' }
                ]
            },
            {
                titleKey: 'simulation.gear',
                events: [
                    { id: 'GEAR_DRIVE', labelKey: 'simulation.gearDrive' },
                    { id: 'GEAR_REVERSE', labelKey: 'simulation.gearReverse' },
                    { id: 'GEAR_PARK', labelKey: 'simulation.gearPark' }
                ]
            },
            {
                titleKey: 'simulation.blindspot',
                events: [
                    { id: 'BLINDSPOT_LEFT', labelKey: 'simulation.blindspotLeft' },
                    { id: 'BLINDSPOT_RIGHT', labelKey: 'simulation.blindspotRight' },
                    { id: 'BLINDSPOT_WARNING', labelKey: 'simulation.blindspotWarning' }
                ]
            },
            {
                titleKey: 'simulation.sentry',
                events: [
                    { id: 'SENTRY_MODE_ON', labelKey: 'simulation.sentryOn' },
                    { id: 'SENTRY_MODE_OFF', labelKey: 'simulation.sentryOff' },
                    { id: 'SENTRY_ALERT', labelKey: 'simulation.sentryAlert' }
                ]
            }
        ];
        // Language & theme management
        let currentLang = localStorage.getItem('language') || 'en';
        let currentTheme = localStorage.getItem('theme') || 'dark';
        function updateBleUiState() {
            const button = document.getElementById('ble-connect-button');
            const statusPill = document.getElementById('ble-status-pill');
            const helper = document.getElementById('ble-helper-text');
            if (!button || !statusPill || !helper) {
                return;
            }
            const supported = bleTransport.isSupported();
            if (!supported) {
                button.hidden = true;
                button.disabled = true;
                button.dataset.i18n = 'ble.connect';
                button.textContent = t('ble.connect');
                statusPill.classList.remove('connected');
                statusPill.dataset.i18n = 'ble.statusUnsupported';
                statusPill.textContent = t('ble.statusUnsupported');
                helper.hidden = false;
                return;
            }
            helper.hidden = true;
            const status = bleTransport.getStatus();
            if (status === 'connected') {
                button.disabled = false;
                button.dataset.i18n = 'ble.disconnect';
                button.textContent = t('ble.disconnect');
                statusPill.classList.add('connected');
                statusPill.dataset.i18n = 'ble.connected';
                statusPill.textContent = t('ble.connected');
            } else if (status === 'connecting') {
                button.disabled = true;
                button.dataset.i18n = 'ble.connecting';
                button.textContent = t('ble.connecting');
                statusPill.classList.remove('connected');
                statusPill.dataset.i18n = 'ble.connecting';
                statusPill.textContent = t('ble.connecting');
            } else {
                button.disabled = false;
                button.dataset.i18n = 'ble.connect';
                button.textContent = t('ble.connect');
                statusPill.classList.remove('connected');
                statusPill.dataset.i18n = 'ble.disconnected';
                statusPill.textContent = t('ble.disconnected');
            }
        }
        async function toggleBleConnection() {
            if (!bleTransport.isSupported()) {
                showNotification('ble-notification', t('ble.notSupported'), 'error');
                return;
            }
            const status = bleTransport.getStatus();
            if (status === 'connecting') {
                return;
            }
            try {
                if (bleTransport.isConnected()) {
                    await bleTransport.disconnect();
                } else {
                    await bleTransport.connect();
                }
            } catch (error) {
                console.error('BLE toggle error', error);
                const message = t('ble.toastError') + (error && error.message ? ' - ' + error.message : '');
                showNotification('ble-notification', message, 'error');
            } finally {
                updateBleUiState();
            }
        }
        function setLanguage(lang) {
            if (!lang || lang === currentLang) {
                updateLanguageSelector();
                return;
            }
            currentLang = lang;
            localStorage.setItem('language', currentLang);
            applyTranslations();
            renderSimulationSections();
            renderEventsTable();
        }
        function toggleLanguage() {
            setLanguage(currentLang === 'fr' ? 'en' : 'fr');
        }
        function updateLanguageSelector() {
            const select = document.getElementById('language-select');
            if (select) {
                select.value = currentLang;
            }
        }
        function applyTheme() {
            document.body.classList.toggle('light-theme', currentTheme === 'light');
            const select = document.getElementById('theme-select');
            if (select) {
                select.value = currentTheme;
            }
        }
        function setTheme(theme) {
            if (!theme) return;
            currentTheme = theme;
            localStorage.setItem('theme', currentTheme);
            applyTheme();
        }
        function applyTranslations() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const keys = key.split('.');
                let value = translations[currentLang];
                for (let k of keys) {
                    value = value[k];
                }
                if (value) {
                    el.textContent = value;
                }
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                const keys = key.split('.');
                let value = translations[currentLang];
                for (let k of keys) {
                    value = value[k];
                }
                if (value) {
                    el.placeholder = value;
                }
            });
            // Update select options
            updateSelectOptions();
            refreshEffectOptionLabels();
            updateLanguageSelector();
            const themeSelect = document.getElementById('theme-select');
            if (themeSelect) {
                themeSelect.value = currentTheme;
            }
            updateBleUiState();
        }
        function updateSelectOptions() {
            const effectSelect = document.getElementById('effect-select');
            if (effectSelect) {
                Array.from(effectSelect.options).forEach(opt => {
                    const key = opt.getAttribute('data-i18n');
                    if (key) {
                        const keys = key.split('.');
                        let value = translations[currentLang];
                        for (let k of keys) {
                            value = value[k];
                        }
                        if (value) opt.textContent = value;
                    }
                });
            }
        }
        function refreshEffectOptionLabels() {
            const selects = document.querySelectorAll('select[data-effect-options]');
            selects.forEach(select => {
                Array.from(select.options).forEach(opt => {
                    const effectId = opt.value;
                    if (!effectId) return;
                    const translated = translateEffectId(effectId);
                    if (translated) {
                        opt.textContent = translated;
                    } else {
                        const fallback = opt.getAttribute('data-effect-name');
                        if (fallback) {
                            opt.textContent = fallback;
                        }
                    }
                });
            });
        }
        function t(key) {
            const keys = key.split('.');
            let value = translations[currentLang];
            for (let k of keys) {
                value = value[k];
            }
            return value || key;
        }
        // Gestion des tabs
        // État des toggles de simulation (persiste entre les changements d'onglets)
        let simulationTogglesState = {};
        let simulationAutoStopTimers = {};
        function isSimulationEventEnabled(eventType) {
            const config = getSimulationEventConfig(eventType);
            if (!config) {
                return true;
            }
            return config.enabled !== false;
        }
        function switchTab(tabName) {
            // Désactiver tous les tabs
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            // Activer le tab sélectionné
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
            // Load data for specific tabs
            if (tabName === 'events-config') {
                loadEventsConfig();
            } else if (tabName === 'config') {
                loadHardwareConfig();
            } else if (tabName === 'simulation') {
                // Restaurer l'état des toggles de simulation
                restoreSimulationToggles();
            }
        }
        function restoreSimulationToggles() {
            // Restaurer l'état de tous les toggles
            Object.keys(simulationTogglesState).forEach(eventId => {
                const checkbox = document.getElementById('toggle-' + eventId);
                if (checkbox) {
                    checkbox.checked = simulationTogglesState[eventId];
                }
                setToggleContainerState(eventId, simulationTogglesState[eventId]);
            });
            // Restaurer le toggle du mode nuit
            const nightModeCheckbox = document.getElementById('toggle-nightmode');
            if (nightModeCheckbox && simulationTogglesState['nightmode'] !== undefined) {
                nightModeCheckbox.checked = simulationTogglesState['nightmode'];
            }
        }
        function getSimulationEventConfig(eventType) {
            if (!eventsConfigData || eventsConfigData.length === 0) {
                return null;
            }
            const normalized = typeof eventType === 'string' ? eventType : String(eventType);
            return eventsConfigData.find(evt => evt.event === normalized) || null;
        }
        function cancelSimulationAutoStop(eventType) {
            if (simulationAutoStopTimers[eventType]) {
                clearTimeout(simulationAutoStopTimers[eventType]);
                delete simulationAutoStopTimers[eventType];
            }
        }
        function scheduleSimulationAutoStop(eventType, durationMs) {
            if (!durationMs || durationMs <= 0) {
                return;
            }
            cancelSimulationAutoStop(eventType);
            simulationAutoStopTimers[eventType] = setTimeout(() => {
                autoStopSimulationEvent(eventType);
            }, durationMs);
        }
        async function autoStopSimulationEvent(eventType) {
            cancelSimulationAutoStop(eventType);
            const checkbox = document.getElementById('toggle-' + eventType);
            if (checkbox) {
                checkbox.checked = false;
            }
            await toggleEvent(eventType, false);
        }
        async function getSimulationEventDuration(eventType) {
            try {
                await ensureEventsConfigData();
            } catch (error) {
                return 0;
            }
            const config = getSimulationEventConfig(eventType);
            return config && typeof config.duration === 'number' ? config.duration : 0;
        }
        function renderSimulationSections() {
            const container = document.getElementById('simulation-sections');
            if (!container) return;
            container.innerHTML = '';
            simulationSections.forEach(section => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'section';
                const title = document.createElement('div');
                title.className = 'section-title';
                title.style.fontSize = '16px';
                title.setAttribute('data-i18n', section.titleKey);
                title.textContent = t(section.titleKey);
                sectionDiv.appendChild(title);
                const grid = document.createElement('div');
                grid.className = 'simulation-grid';
                section.events.forEach(event => {
                    const toggleContainer = document.createElement('div');
                    toggleContainer.className = 'event-toggle-container';
                    toggleContainer.id = 'event-toggle-' + event.id;
                    const eventConfig = getSimulationEventConfig(event.id);
                    const eventEnabledInConfig = isSimulationEventEnabled(event.id);
                    if (eventConfig && !eventEnabledInConfig) {
                        simulationTogglesState[event.id] = false;
                    }
                    const label = document.createElement('label');
                    label.className = 'event-toggle-label';
                    label.htmlFor = 'toggle-' + event.id;
                    label.setAttribute('data-i18n', event.labelKey);
                    label.textContent = t(event.labelKey);
                    const toggle = document.createElement('label');
                    toggle.className = 'toggle-switch';
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.id = 'toggle-' + event.id;
                    input.checked = eventEnabledInConfig && !!simulationTogglesState[event.id];
                    input.disabled = !eventEnabledInConfig;
                    input.addEventListener('change', (e) => toggleEvent(event.id, e.target.checked));
                    const slider = document.createElement('span');
                    slider.className = 'toggle-slider';
                    toggle.appendChild(input);
                    toggle.appendChild(slider);
                    if (simulationTogglesState[event.id]) {
                        toggleContainer.classList.add('active');
                    }
                    toggleContainer.classList.toggle('disabled', !eventEnabledInConfig);
                    toggleContainer.appendChild(label);
                    toggleContainer.appendChild(toggle);
                    grid.appendChild(toggleContainer);
                });
                sectionDiv.appendChild(grid);
                container.appendChild(sectionDiv);
            });
        }
        function setToggleContainerState(eventType, isActive) {
            const container = document.getElementById('event-toggle-' + eventType);
            if (container) {
                container.classList.toggle('active', !!isActive);
            }
        }
        // Conversion pourcentage <-> 0-255
        function percentTo255(percent) {
            return Math.round((percent * 255) / 100);
        }
        function to255ToPercent(value) {
            return Math.round((value * 100) / 255);
        }
        // Mise à jour des sliders avec pourcentage (seulement ceux qui existent)
        const nightBrightnessSlider = document.getElementById('night-brightness-slider');
        if (nightBrightnessSlider) {
            nightBrightnessSlider.oninput = function() {
                document.getElementById('night-brightness-value').textContent = this.value + '%';
            };
        }
        const defaultBrightnessSlider = document.getElementById('default-brightness-slider');
        if (defaultBrightnessSlider) {
            defaultBrightnessSlider.oninput = function() {
                document.getElementById('default-brightness-value').textContent = this.value + '%';
                scheduleDefaultEffectSave();
            };
        }
        const defaultSpeedSlider = document.getElementById('default-speed-slider');
        if (defaultSpeedSlider) {
            defaultSpeedSlider.oninput = function() {
                document.getElementById('default-speed-value').textContent = this.value + '%';
                scheduleDefaultEffectSave();
            };
        }
        const defaultColorInput = document.getElementById('default-color1');
        if (defaultColorInput) {
            defaultColorInput.addEventListener('change', scheduleDefaultEffectSave);
        }
        const defaultEffectSelect = document.getElementById('default-effect-select');
        if (defaultEffectSelect) {
            defaultEffectSelect.addEventListener('change', scheduleDefaultEffectSave);
        }
        // Notification helper
        function showNotification(elementId, message, type, timeout = 2000) {
            const notification = document.getElementById(elementId);
            notification.textContent = message;
            notification.className = 'notification ' + type + ' show';
            setTimeout(() => {
                notification.classList.remove('show');
            }, timeout);
        }
        async function parseApiResponse(response) {
            const rawText = await response.text();
            let data = null;
            if (rawText) {
                try {
                    data = JSON.parse(rawText);
                } catch (e) {
                    data = null;
                }
            }
            const status = data && typeof data.status === 'string' ? data.status : null;
            const success = response.ok && (status === null || status === 'ok');
            return { success, data, raw: rawText };
        }
        // Events Configuration
        let eventsConfigData = [];
        const EVENT_SAVE_DEBOUNCE_MS = 700;
        const DEFAULT_EFFECT_DEBOUNCE_MS = 700;
        const eventAutoSaveTimers = new Map();
        let defaultEffectSaveTimer = null;
        let eventsConfigLoadingPromise = null;
        function getDefaultEffectId() {
            if (effectsList.length === 0) {
                return 'OFF';
            }
            const offEffect = effectsList.find(effect => effect.id === 'OFF');
            if (offEffect) {
                return offEffect.id;
            }
            const nonCan = effectsList.find(effect => !effect.can_required);
            if (nonCan) {
                return nonCan.id;
            }
            return effectsList[0].id;
        }
        async function ensureEventsConfigData(forceRefresh = false) {
            if (!forceRefresh && eventsConfigData.length > 0) {
                return eventsConfigData;
            }
            if (!forceRefresh && eventsConfigLoadingPromise) {
                return eventsConfigLoadingPromise;
            }
            const fetchPromise = (async () => {
                try {
                    const response = await fetch(API_BASE + '/api/events');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    eventsConfigData = data.events || [];
                    return eventsConfigData;
                } catch (error) {
                    console.error('Failed to load events config:', error);
                    throw error;
                }
            })();
            if (!forceRefresh) {
                eventsConfigLoadingPromise = fetchPromise.finally(() => {
                    eventsConfigLoadingPromise = null;
                });
                return eventsConfigLoadingPromise;
            }
            return fetchPromise;
        }
        async function loadEventsConfig() {
            const loading = document.getElementById('events-loading');
            const content = document.getElementById('events-content');
            loading.style.display = 'block';
            content.style.display = 'none';
            try {
                await ensureEventsConfigData(true);
                renderEventsTable();
                renderSimulationSections();
                loading.style.display = 'none';
                content.style.display = 'block';
            } catch (e) {
                console.error('Error:', e);
                showNotification('events-notification', t('eventsConfig.loadError'), 'error');
                loading.style.display = 'none';
            }
        }
        function renderEventsTable() {
            const tbody = document.getElementById('events-table-body');
            tbody.innerHTML = '';
            // If no data from API, create default rows for all events
            if (eventsConfigData.length === 0) {
                const defaultEffectId =
                    effectsList.find(effect => !effect.can_required)?.id ||
                    effectsList[0]?.id ||
                    'OFF';
                if (eventTypesList.length > 0) {
                    eventTypesList
                        .filter(evt => evt.id !== 'NONE')
                        .forEach(evt => {
                            eventsConfigData.push({
                                event: evt.id,
                                effect: defaultEffectId,
                                brightness: 128,
                                speed: 128,
                                color: 0xFF0000,
                                duration: 0,
                                priority: 100,
                                enabled: true,
                                action_type: 0,
                                profile_id: -1,
                                can_switch_profile: false
                            });
                        });
                }
            }
            eventsConfigData.forEach((event, index) => {
                // Skip CAN_EVENT_NONE only
                if (event.event === 'NONE') {
                    return;
                }
                const row = document.createElement('tr');
                const eventName = getEventName(event.event);
                const actionType = event.action_type !== undefined ? event.action_type : 0;
                const canSwitchProfile = event.can_switch_profile || false;
                const profileId = event.profile_id !== undefined ? event.profile_id : -1;
                // Générer les options d'action
                let actionOptions = '';
                actionOptions += `<option value="0" ${actionType === 0 ? 'selected' : ''}>${t('eventsConfig.applyEffect')}</option>`;
                if (canSwitchProfile) {
                    actionOptions += `<option value="1" ${actionType === 1 ? 'selected' : ''}>${t('eventsConfig.switchProfile')}</option>`;
                }
                // Générer les options de profil
                const profileSelect = document.getElementById('profile-select');
                let profileOptions = '<option value="-1">--</option>';
                if (profileSelect) {
                    for (let i = 0; i < profileSelect.options.length; i++) {
                        const opt = profileSelect.options[i];
                        profileOptions += `<option value="${opt.value}" ${profileId == opt.value ? 'selected' : ''}>${opt.text}</option>`;
                    }
                }
                row.innerHTML = `
                    <td class="event-name-cell">${eventName}</td>
                    <td>
                        <select onchange="updateEventConfig(${index}, 'action_type', parseInt(this.value)); renderEventsTable();" ${!canSwitchProfile ? 'disabled style="display:none"' : ''}>
                            ${actionOptions}
                        </select>
                    </td>
                    <td>
                        <select onchange="updateEventConfig(${index}, 'profile_id', parseInt(this.value))" ${actionType === 0 || !canSwitchProfile ? 'disabled style="display:none"' : ''}>
                            ${profileOptions}
                        </select>
                    </td>
                    <td>
                        <select data-effect-options="true" onchange="updateEventConfig(${index}, 'effect', this.value)" ${actionType === 1 ? 'disabled style="display:none"' : ''}>
                            ${effectsList.map(effect =>
                                `<option value="${effect.id}" data-effect-name="${effect.name}" ${event.effect == effect.id ? 'selected' : ''}>${getEffectName(effect.id)}</option>`
                            ).join('')}
                        </select>
                    </td>
                    <td>
                        <input type="number" min="0" max="255" value="${event.brightness}"
                            onchange="updateEventConfig(${index}, 'brightness', parseInt(this.value))" ${actionType === 1 ? 'disabled style="display:none"' : ''}>
                    </td>
                    <td>
                        <input type="number" min="0" max="255" value="${event.speed}"
                            onchange="updateEventConfig(${index}, 'speed', parseInt(this.value))" ${actionType === 1 ? 'disabled style="display:none"' : ''}>
                    </td>
                    <td>
                        <input type="color" value="#${event.color.toString(16).padStart(6, '0')}"
                            onchange="updateEventConfig(${index}, 'color', parseInt(this.value.substring(1), 16))" ${actionType === 1 ? 'disabled style="display:none"' : ''}>
                    </td>
                    <td>
                        <input type="number" min="0" max="60000" step="100" value="${event.duration}"
                            onchange="updateEventConfig(${index}, 'duration', parseInt(this.value))" ${actionType === 1 ? 'disabled style="display:none"' : ''}>
                    </td>
                    <td>
                        <input type="number" min="0" max="255" value="${event.priority}"
                            onchange="updateEventConfig(${index}, 'priority', parseInt(this.value))" ${actionType === 1 ? 'disabled style="display:none"' : ''}>
                    </td>
                    <td style="text-align: center;">
                        <input type="checkbox" ${event.enabled ? 'checked' : ''}
                            onchange="updateEventConfig(${index}, 'enabled', this.checked)">
                    </td>
                `;
                tbody.appendChild(row);
            });
        }
        function updateEventConfig(index, field, value) {
            eventsConfigData[index][field] = value;
            if (field === 'action_type') {
                const event = eventsConfigData[index];
                if (value === 0) {
                    event.profile_id = -1;
                } else if (value === 1) {
                    event.effect = getDefaultEffectId();
                } else if (value === 2) {
                    if (event.profile_id === undefined || event.profile_id === null) {
                        event.profile_id = -1;
                    }
                    if (!event.effect) {
                        event.effect = getDefaultEffectId();
                    }
                }
            }
            scheduleEventAutoSave(index);
        }
        function scheduleEventAutoSave(index) {
            if (!eventsConfigData[index]) {
                return;
            }
            if (eventAutoSaveTimers.has(index)) {
                clearTimeout(eventAutoSaveTimers.get(index));
            }
            const timer = setTimeout(() => {
                eventAutoSaveTimers.delete(index);
                autoSaveEvent(index);
            }, EVENT_SAVE_DEBOUNCE_MS);
            eventAutoSaveTimers.set(index, timer);
        }
        function buildEventPayload(event) {
            if (!event) {
                return null;
            }
            const allowedKeys = [
                'event', 'effect', 'brightness', 'speed', 'color',
                'duration', 'priority', 'enabled', 'action_type', 'profile_id'
            ];
            const payload = {};
            allowedKeys.forEach(key => {
                if (event[key] !== undefined) {
                    payload[key] = event[key];
                }
            });
            return payload;
        }
        async function autoSaveEvent(index) {
            const payload = buildEventPayload(eventsConfigData[index]);
            if (!payload) {
                return;
            }
            try {
                const response = await fetch(API_BASE + '/api/events/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event: payload })
                });
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status);
                }
            } catch (error) {
                console.error('Event auto-save failed', error);
                showNotification('events-notification', t('eventsConfig.saveError'), 'error');
            }
        }
        function scheduleDefaultEffectSave() {
            if (defaultEffectSaveTimer) {
                clearTimeout(defaultEffectSaveTimer);
            }
            defaultEffectSaveTimer = setTimeout(() => {
                defaultEffectSaveTimer = null;
                saveDefaultEffect(true);
            }, DEFAULT_EFFECT_DEBOUNCE_MS);
        }
        // Hardware Configuration
        async function loadHardwareConfig() {
            try {
                const response = await fetch(API_BASE + '/api/config');
                const config = await response.json();
                if (config.led_count !== undefined) {
                    document.getElementById('led-count').value = config.led_count;
                }
                if (config.data_pin !== undefined) {
                    document.getElementById('data-pin').value = config.data_pin;
                }
                if (config.strip_reverse !== undefined) {
                    document.getElementById('strip-reverse').checked = config.strip_reverse;
                }
            } catch (e) {
                console.error('Error:', e);
                showNotification('config-notification', t('config.loadError'), 'error');
            }
        }
        async function saveHardwareConfig() {
            const config = {
                led_count: parseInt(document.getElementById('led-count').value),
                data_pin: parseInt(document.getElementById('data-pin').value),
                strip_reverse: document.getElementById('strip-reverse').checked
            };
            try {
                const response = await fetch(API_BASE + '/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                if (response.ok) {
                    showNotification('config-notification', t('config.saveSuccess'), 'success');
                } else {
                    showNotification('config-notification', t('config.saveError'), 'error');
                }
            } catch (e) {
                console.error('Error:', e);
                showNotification('config-notification', t('config.saveError'), 'error');
            }
        }
        // Factory Reset
        function confirmFactoryReset() {
            if (confirm(t('config.factoryResetConfirm'))) {
                performFactoryReset();
            }
        }
        async function performFactoryReset() {
            try {
                showNotification('config-notification', t('config.factoryResetInProgress'), 'info');
                const response = await fetch(API_BASE + '/api/factory-reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                if (response.ok && data.status === 'ok') {
                    showNotification('config-notification', t('config.factoryResetSuccess'), 'success');
                    // L'ESP32 va redémarrer, afficher un message
                    setTimeout(() => {
                        alert(t('config.deviceRestarting'));
                        location.reload();
                    }, 2000);
                } else {
                    showNotification('config-notification', data.message || t('config.factoryResetError'), 'error');
                }
            } catch (e) {
                console.error('Error:', e);
                showNotification('config-notification', t('config.factoryResetError'), 'error');
            }
        }
        // Gestion des profils
        async function loadProfiles() {
            try {
                const response = await fetch(API_BASE + '/api/profiles');
                const data = await response.json();
                const select = document.getElementById('profile-select');
                select.innerHTML = '';
                data.profiles.forEach(profile => {
                    const option = document.createElement('option');
                    option.value = profile.id;
                    option.textContent = profile.name + (profile.active ? ' ✓' : '');
                    if (profile.active) option.selected = true;
                    select.appendChild(option);
                });
                document.getElementById('profile-status').textContent = data.active_name;
            } catch (e) {
                console.error('Erreur:', e);
            }
        }
        async function activateProfile() {
            const profileId = parseInt(document.getElementById('profile-select').value);
            try {
                await fetch(API_BASE + '/api/profile/activate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ profile_id: profileId })
                });
                loadProfiles();
                loadConfig();
            } catch (e) {
                console.error('Erreur:', e);
            }
        }
        function showNewProfileDialog() {
            document.getElementById('newProfileModal').classList.add('active');
        }
        function hideNewProfileDialog() {
            document.getElementById('newProfileModal').classList.remove('active');
        }
        async function createProfile() {
            const name = document.getElementById('new-profile-name').value;
            if (!name) return;
            try {
                const response = await fetch(API_BASE + '/api/profile/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name })
                });
                const apiResult = await parseApiResponse(response);
                if (apiResult.success) {
                    hideNewProfileDialog();
                    document.getElementById('new-profile-name').value = '';
                    loadProfiles();
                    showNotification('profiles-notification', t('profiles.create') + ' ' + t('config.saveSuccess'), 'success');
                } else {
                    const message = apiResult.data?.message || apiResult.raw || t('config.saveError');
                    showNotification('profiles-notification', message, 'error');
                }
            } catch (e) {
                console.error('Erreur:', e);
                showNotification('profiles-notification', e.message || t('config.saveError'), 'error');
            }
        }
        async function deleteProfile() {
            const profileId = parseInt(document.getElementById('profile-select').value);
            if (!confirm(t('profiles.deleteConfirm'))) return;
            try {
                const response = await fetch(API_BASE + '/api/profile/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ profile_id: profileId })
                });
                const apiResult = await parseApiResponse(response);
                if (apiResult.success) {
                    loadProfiles();
                    showNotification('profiles-notification', t('profiles.delete') + ' ' + t('config.saveSuccess'), 'success');
                } else {
                    const message = apiResult.data?.message || apiResult.raw || t('config.saveError');
                    showNotification('profiles-notification', message, 'error');
                }
            } catch (e) {
                console.error('Erreur:', e);
                showNotification('profiles-notification', e.message || t('config.saveError'), 'error');
            }
        }
        async function exportProfile() {
            const profileId = parseInt(document.getElementById('profile-select').value);
            if (profileId < 0) {
                showNotification('profiles-notification', t('profiles.selectProfile'), 'error');
                return;
            }
            try {
                const response = await fetch(API_BASE + '/api/profile/export?profile_id=' + profileId);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = 'profile_' + profileId + '.json';
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    showNotification('profiles-notification', t('profiles.exportSuccess'), 'success');
                } else {
                    showNotification('profiles-notification', t('profiles.exportError'), 'error');
                }
            } catch (e) {
                console.error('Erreur export:', e);
                showNotification('profiles-notification', t('profiles.exportError'), 'error');
            }
        }
        function showImportDialog() {
            const profileId = parseInt(document.getElementById('profile-select').value);
            if (profileId < 0) {
                showNotification('profiles-notification', t('profiles.selectProfile'), 'error');
                return;
            }
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const profileData = JSON.parse(event.target.result);
                        const response = await fetch(API_BASE + '/api/profile/import', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                profile_id: profileId,
                                profile_data: profileData
                            })
                        });
                        const result = await response.json();
                        if (result.status === 'ok') {
                            showNotification('profiles-notification', t('profiles.importSuccess'), 'success');
                            loadProfiles();
                        } else {
                            showNotification('profiles-notification', t('profiles.importError'), 'error');
                        }
                    } catch (e) {
                        console.error('Erreur import:', e);
                        showNotification('profiles-notification', t('profiles.importError'), 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        async function saveProfileSettings() {
            const profileId = parseInt(document.getElementById('profile-select').value);
            const autoNightMode = document.getElementById('auto-night-mode').checked;
            const nightBrightness = percentTo255(parseInt(document.getElementById('night-brightness-slider').value));
            try {
                const response = await fetch(API_BASE + '/api/profile/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        profile_id: profileId,
                        auto_night_mode: autoNightMode,
                        night_brightness: nightBrightness
                    })
                });
                const apiResult = await parseApiResponse(response);
                if (apiResult.success) {
                    showNotification('profiles-notification', t('config.saveSuccess'), 'success');
                } else {
                    const message = apiResult.data?.message || apiResult.raw || t('config.saveError');
                    showNotification('profiles-notification', message, 'error');
                }
            } catch (e) {
                console.error('Error saving profile settings:', e);
                showNotification('profiles-notification', e.message || t('config.saveError'), 'error');
            }
        }
        async function saveDefaultEffect(silent = false) {
            const profileId = parseInt(document.getElementById('profile-select').value);
            const effectId = document.getElementById('default-effect-select').value;
            const effect = effectIdToEnum(effectId); // Convert string ID to numeric enum
            const brightness = percentTo255(parseInt(document.getElementById('default-brightness-slider').value));
            const speed = percentTo255(parseInt(document.getElementById('default-speed-slider').value));
            const color1 = parseInt(document.getElementById('default-color1').value.substring(1), 16);
            try {
                const response = await fetch(API_BASE + '/api/profile/update/default', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        profile_id: profileId,
                        effect: effect,
                        brightness: brightness,
                        speed: speed,
                        color1: color1
                    })
                });
                const apiResult = await parseApiResponse(response);
                if (apiResult.success) {
                    if (!silent) {
                        showNotification('profiles-notification', t('profiles.saveDefault') + ' ' + t('config.saveSuccess'), 'success');
                    }
                } else {
                    const message = apiResult.data?.message || apiResult.raw || t('config.saveError');
                    showNotification('profiles-notification', message, 'error');
                }
            } catch (e) {
                console.error('Error saving default effect:', e);
                showNotification('profiles-notification', e.message || t('config.saveError'), 'error');
            }
        }
        // Appliquer l'effet
        async function applyEffect() {
            const config = {
                effect: parseInt(document.getElementById('effect-select').value),
                brightness: percentTo255(parseInt(document.getElementById('brightness-slider').value)),
                speed: percentTo255(parseInt(document.getElementById('speed-slider').value)),
                color1: parseInt(document.getElementById('color1').value.substring(1), 16),
                color2: 0,
                color3: 0
            };
            try {
                await fetch(API_BASE + '/api/effect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
            } catch (e) {
                console.error('Erreur:', e);
            }
        }
        // Sauvegarder la configuration
        async function saveConfig() {
            try {
                await fetch(API_BASE + '/api/save', { method: 'POST' });
                showNotification('profiles-notification', t('effects.save'), 'success');
            } catch (e) {
                console.error('Erreur:', e);
                showNotification('profiles-notification', t('config.saveError'), 'error');
            }
        }
        // Assigner un effet à un événement
        async function assignEventEffect() {
            const data = {
                event: parseInt(document.getElementById('can-event-select').value),
                effect: document.getElementById('event-effect-select').value,
                duration: parseInt(document.getElementById('event-duration').value),
                priority: parseInt(document.getElementById('event-priority-slider').value),
                brightness: percentTo255(parseInt(document.getElementById('brightness-slider').value)),
                speed: percentTo255(parseInt(document.getElementById('speed-slider').value)),
                color1: parseInt(document.getElementById('color1').value.substring(1), 16)
            };
            try {
                await fetch(API_BASE + '/api/event-effect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                showNotification('events-notification', t('canEvents.assignSuccess'), 'success');
            } catch (e) {
                console.error('Erreur:', e);
                showNotification('events-notification', t('config.saveError'), 'error');
            }
        }
        // Commander
        async function connectCommander() {
            try {
                await fetch(API_BASE + '/api/commander/connect', { method: 'POST' });
                showNotification('commander-notification', t('commander.connecting'), 'success');
                updateStatus();
            } catch (e) {
                console.error('Erreur:', e);
            }
        }
        async function disconnectCommander() {
            try {
                await fetch(API_BASE + '/api/commander/disconnect', { method: 'POST' });
                updateStatus();
            } catch (e) {
                console.error('Erreur:', e);
            }
        }
        // Mise à jour du statut
        async function updateStatus() {
            try {
                const response = await fetch(API_BASE + '/api/status');
                const data = await response.json();
                document.getElementById('wifi-status').textContent = data.wifi_connected ? t('status.connected') : t('status.ap');
                document.getElementById('wifi-status').className = 'status-value ' + (data.wifi_connected ? 'status-online' : 'status-offline');
                document.getElementById('commander-status').textContent = data.commander_connected ? t('status.connected') : t('status.disconnected');
                document.getElementById('commander-status').className = 'status-value ' + (data.commander_connected ? 'status-online' : 'status-offline');
                document.getElementById('vehicle-status').textContent = data.vehicle_active ? t('status.active') : t('status.inactive');
                document.getElementById('vehicle-status').className = 'status-value ' + (data.vehicle_active ? 'status-online' : 'status-offline');
                if (data.active_profile_name) {
                    document.getElementById('profile-status').textContent = data.active_profile_name;
                }
                // Données véhicule complètes
                if (data.vehicle && data.vehicle_active) {
                    const v = data.vehicle;
                    // État général
                    document.getElementById('v-ignition').textContent = v.ignition_on ? t('status.active') : t('status.inactive');
                    document.getElementById('v-speed').textContent = v.speed.toFixed(1) + ' km/h';
                    document.getElementById('v-gear').textContent = ['P', 'R', 'N', 'D'][v.gear] || '--';
                    document.getElementById('v-brake').textContent = v.brake_pressed ? t('status.active') : t('status.inactive');
                    document.getElementById('v-locked').textContent = v.locked ? t('vehicle.locked') : t('vehicle.unlocked');
                    // Portes
                    if (v.doors) {
                        document.getElementById('v-door-fl').textContent = v.doors.front_left ? t('vehicle.open') : t('vehicle.closed');
                        document.getElementById('v-door-fr').textContent = v.doors.front_right ? t('vehicle.open') : t('vehicle.closed');
                        document.getElementById('v-door-rl').textContent = v.doors.rear_left ? t('vehicle.open') : t('vehicle.closed');
                        document.getElementById('v-door-rr').textContent = v.doors.rear_right ? t('vehicle.open') : t('vehicle.closed');
                        document.getElementById('v-trunk').textContent = v.doors.trunk ? t('vehicle.open') : t('vehicle.closed');
                        document.getElementById('v-frunk').textContent = v.doors.frunk ? t('vehicle.open') : t('vehicle.closed');
                    }
                    // Fenêtres (%)
                    if (v.windows) {
                        document.getElementById('v-window-fl').textContent = v.windows.front_left + '%';
                        document.getElementById('v-window-fr').textContent = v.windows.front_right + '%';
                        document.getElementById('v-window-rl').textContent = v.windows.rear_left + '%';
                        document.getElementById('v-window-rr').textContent = v.windows.rear_right + '%';
                    }
                    // Charge
                    if (v.charge) {
                        document.getElementById('v-charging').textContent = v.charge.charging ? t('status.active') : t('status.inactive');
                        document.getElementById('v-charge').textContent = v.charge.percent + '%';
                        document.getElementById('v-charge-power').textContent = v.charge.power_kw.toFixed(1) + ' kW';
                    }
                    // Lumières
                    if (v.lights) {
                        document.getElementById('v-headlights').textContent = v.lights.headlights ? t('status.active') : t('status.inactive');
                        document.getElementById('v-high-beams').textContent = v.lights.high_beams ? t('status.active') : t('status.inactive');
                        document.getElementById('v-fog-lights').textContent = v.lights.fog_lights ? t('status.active') : t('status.inactive');
                        const turnSignal = ['Off', t('simulation.left'), t('simulation.right'), 'Warning'][v.lights.turn_signal] || 'Off';
                        document.getElementById('v-turn-signal').textContent = turnSignal;
                    }
                    // Batterie et autres
                    document.getElementById('v-battery').textContent = v.battery_12v.toFixed(2) + ' V';
                    document.getElementById('v-odometer').textContent = v.odometer_km.toLocaleString() + ' km';
                    // Sécurité
                    if (v.safety) {
                        document.getElementById('v-night').textContent = v.safety.night_mode ? t('status.active') : t('status.inactive');
                        document.getElementById('v-blindspot-left').textContent = v.safety.blindspot_left ? t('status.active') : t('status.inactive');
                        document.getElementById('v-blindspot-right').textContent = v.safety.blindspot_right ? t('status.active') : t('status.inactive');

                        const sentryModeEl = document.getElementById('v-sentry-mode');
                        if (sentryModeEl) {
                            if (typeof v.safety.sentry_mode === 'boolean') {
                                sentryModeEl.textContent = v.safety.sentry_mode ? t('simulation.sentryOn') : t('simulation.sentryOff');
                            } else {
                                sentryModeEl.textContent = t('vehicle.none');
                            }
                        }

                        const sentryRequestEl = document.getElementById('v-sentry-request');
                        if (sentryRequestEl) {
                            const requestMap = {
                                AUTOPILOT_NOMINAL: t('vehicle.sentryNominal'),
                                AUTOPILOT_SENTRY: t('simulation.sentryOn'),
                                AUTOPILOT_SUSPEND: t('vehicle.sentrySuspend')
                            };
                            const requestState = v.safety.sentry_request;
                            sentryRequestEl.textContent = requestState ? (requestMap[requestState] || requestState) : t('vehicle.none');
                        }

                        const sentryAlertEl = document.getElementById('v-sentry-alert');
                        if (sentryAlertEl) {
                            if (typeof v.safety.sentry_alert === 'boolean') {
                                sentryAlertEl.textContent = v.safety.sentry_alert ? t('simulation.sentryAlert') : t('vehicle.none');
                            } else {
                                sentryAlertEl.textContent = t('vehicle.none');
                            }
                        }
                    }
                } else {
                    // Afficher des tirets quand il n'y a pas de données
                    const fields = [
                        'v-ignition', 'v-speed', 'v-gear', 'v-brake', 'v-locked',
                        'v-door-fl', 'v-door-fr', 'v-door-rl', 'v-door-rr', 'v-trunk', 'v-frunk',
                        'v-window-fl', 'v-window-fr', 'v-window-rl', 'v-window-rr',
                        'v-charging', 'v-charge', 'v-charge-power',
                        'v-headlights', 'v-high-beams', 'v-fog-lights', 'v-turn-signal',
                        'v-battery', 'v-odometer', 'v-night', 'v-blindspot-left', 'v-blindspot-right',
                        'v-sentry-mode', 'v-sentry-request', 'v-sentry-alert'
                    ];
                    fields.forEach(id => {
                        const element = document.getElementById(id);
                        if (element) element.textContent = '--';
                    });
                }
            } catch (e) {
                console.error('Erreur:', e);
            }
        }
        // Chargement de la config
        async function loadConfig() {
            try {
                const response = await fetch(API_BASE + '/api/config');
                const config = await response.json();
                // Convertir 0-255 en pourcentage
                const nightBrightnessPercent = to255ToPercent(config.night_brightness);
                // Charger uniquement les éléments qui existent encore
                const autoNightMode = document.getElementById('auto-night-mode');
                if (autoNightMode) {
                    autoNightMode.checked = config.auto_night_mode;
                }
                const nightBrightnessSlider = document.getElementById('night-brightness-slider');
                if (nightBrightnessSlider) {
                    nightBrightnessSlider.value = nightBrightnessPercent;
                }
                const nightBrightnessValue = document.getElementById('night-brightness-value');
                if (nightBrightnessValue) {
                    nightBrightnessValue.textContent = nightBrightnessPercent + '%';
                }
                // Charger aussi l'effet par défaut du profil actif
                loadActiveProfileDefaultEffect();
            } catch (e) {
                console.error('Erreur:', e);
            }
        }
        // Charger l'effet par défaut du profil actif
        async function loadActiveProfileDefaultEffect() {
            try {
                const response = await fetch(API_BASE + '/api/profiles');
                const data = await response.json();
                const activeProfile = data.profiles.find(p => p.active);
                if (activeProfile && activeProfile.default_effect) {
                    const defaultEffect = activeProfile.default_effect;
                    // Convert numeric enum to string ID for the dropdown
                    const effectId = effectEnumToId(defaultEffect.effect);
                    document.getElementById('default-effect-select').value = effectId;
                    const defBrightnessPercent = to255ToPercent(defaultEffect.brightness);
                    const defSpeedPercent = to255ToPercent(defaultEffect.speed);
                    document.getElementById('default-brightness-slider').value = defBrightnessPercent;
                    document.getElementById('default-brightness-value').textContent = defBrightnessPercent + '%';
                    document.getElementById('default-speed-slider').value = defSpeedPercent;
                    document.getElementById('default-speed-value').textContent = defSpeedPercent + '%';
                    document.getElementById('default-color1').value = '#' + defaultEffect.color1.toString(16).padStart(6, '0');
                }
            } catch (e) {
                console.error('Error loading default effect:', e);
            }
        }
        // OTA Functions
        let otaReloadScheduled = false;
        let otaManualUploadRunning = false;
        function scheduleOtaReload(delayMs) {
            if (otaReloadScheduled) {
                return;
            }
            otaReloadScheduled = true;
            setTimeout(() => window.location.reload(), delayMs);
        }
        async function loadOTAInfo() {
            try {
                const response = await fetch(API_BASE + '/api/ota/info');
                const data = await response.json();
                document.getElementById('ota-version').textContent = 'v' + data.version;
                const progressContainer = document.getElementById('ota-progress-container');
                const progressBar = document.getElementById('ota-progress-bar');
                const progressPercent = document.getElementById('ota-progress-percent');
                const statusMessage = document.getElementById('ota-status-message');
                const uploadBtn = document.getElementById('ota-upload-btn');
                const restartBtn = document.getElementById('ota-restart-btn');
                const fileInputEl = document.getElementById('firmware-file');
                const backendStateKey = getOtaStateKey(data.state);
                if (otaManualUploadRunning && backendStateKey !== 'idle') {
                    otaManualUploadRunning = false;
                }
                const stateKey = otaManualUploadRunning ? 'receiving' : backendStateKey;
                const showProgress = otaManualUploadRunning || (typeof data.state === 'number' && data.state !== 0);
                if (progressContainer && progressBar && progressPercent && statusMessage) {
                    const progressValue = Math.max(0, Math.min(100, Number(data.progress) || 0));
                    if (showProgress || stateKey === 'success' || stateKey === 'error') {
                        progressContainer.style.display = 'block';
                        progressBar.style.width = progressValue + '%';
                        progressPercent.textContent = progressValue + '%';
                    } else {
                        progressContainer.style.display = 'none';
                        progressBar.style.width = '0%';
                        progressPercent.textContent = '0%';
                    }
                    let statusText = t('ota.states.' + stateKey);
                    if (stateKey === 'error' && data.error) {
                        statusText += ' - ' + data.error;
                    }
                    statusMessage.textContent = statusText;
                    if (stateKey === 'success') {
                        statusMessage.style.color = '#10b981';
                    } else if (stateKey === 'error') {
                        statusMessage.style.color = '#f87171';
                    } else {
                        statusMessage.style.color = 'var(--color-muted)';
                    }
                }
                const busy = stateKey === 'receiving' || stateKey === 'writing';
                if (uploadBtn) {
                    const effectiveBusy = busy || otaManualUploadRunning;
                    uploadBtn.disabled = effectiveBusy;
                    uploadBtn.style.display = effectiveBusy ? 'none' : 'inline-block';
                }
                if (fileInputEl) {
                    const effectiveBusy = busy || otaManualUploadRunning;
                    fileInputEl.disabled = effectiveBusy;
                    fileInputEl.style.display = effectiveBusy ? 'none' : 'block';
                }
                if (restartBtn) {
                    restartBtn.style.display = stateKey === 'success' ? 'inline-block' : 'none';
                }
                const rebootCountdownEl = document.getElementById('ota-reboot-countdown');
                if (rebootCountdownEl) {
                    if (typeof data.reboot_countdown === 'number' && data.reboot_countdown >= 0) {
                        if (progressContainer) {
                            progressContainer.style.display = 'block';
                        }
                        rebootCountdownEl.style.display = 'block';
                        if (data.reboot_countdown === 0) {
                            rebootCountdownEl.textContent = t('ota.restarting');
                            scheduleOtaReload(5000);
                        } else {
                            rebootCountdownEl.textContent = t('ota.autoRestartIn') + ' ' + data.reboot_countdown + 's';
                            if (data.reboot_countdown <= 5) {
                                scheduleOtaReload((data.reboot_countdown + 2) * 1000);
                            }
                        }
                    } else {
                        rebootCountdownEl.style.display = 'none';
                    }
                }
            } catch (e) {
                console.error('Erreur:', e);
                document.getElementById('ota-version').innerHTML = '<span data-i18n="ota.loading">' + t('ota.loading') + '</span>';
                const rebootCountdownEl = document.getElementById('ota-reboot-countdown');
                if (rebootCountdownEl) {
                    rebootCountdownEl.style.display = 'none';
                }
            }
        }
        async function uploadFirmware() {
            const fileInputEl = document.getElementById('firmware-file');
            const file = fileInputEl.files[0];
            if (!file) {
                showNotification('ota-notification', t('ota.selectFile'), 'error');
                return;
            }
            if (!file.name.endsWith('.bin')) {
                showNotification('ota-notification', t('ota.wrongExtension'), 'error');
                return;
            }
            if (!confirm(t('ota.confirmUpdate'))) {
                return;
            }
            const progressContainer = document.getElementById('ota-progress-container');
            const progressBar = document.getElementById('ota-progress-bar');
            const progressPercent = document.getElementById('ota-progress-percent');
            const statusMessage = document.getElementById('ota-status-message');
            const uploadBtn = document.getElementById('ota-upload-btn');
            const restartBtn = document.getElementById('ota-restart-btn');
            otaManualUploadRunning = true;
            progressContainer.style.display = 'block';
            uploadBtn.disabled = true;
            uploadBtn.style.display = 'none';
            if (fileInputEl) {
                fileInputEl.disabled = true;
                fileInputEl.style.display = 'none';
            }
            statusMessage.textContent = t('ota.states.receiving');
            statusMessage.style.color = 'var(--color-muted)';
            setInterval(loadOTAInfo, 1000);
            try {
                await waitForApiConnection();
                const xhr = new XMLHttpRequest();
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percent = Math.round((e.loaded / e.total) * 100);
                        progressBar.style.width = percent + '%';
                        progressPercent.textContent = percent + '%';
                        statusMessage.textContent = t('ota.states.receiving') + ' (' + percent + '%)';
                    }
                });
                xhr.addEventListener('load', () => {
                    if (xhr.status === 200) {
                        progressBar.style.width = '100%';
                        progressPercent.textContent = '100%';
                        statusMessage.textContent = t('ota.states.writing');
                        statusMessage.style.color = 'var(--color-muted)';
                        restartBtn.style.display = 'inline-block';
                        uploadBtn.style.display = 'none';
                    } else {
                        statusMessage.textContent = t('ota.states.error');
                        statusMessage.style.color = '#f87171';
                        uploadBtn.disabled = false;
                        uploadBtn.style.display = 'inline-block';
                        if (fileInputEl) {
                            fileInputEl.disabled = false;
                            fileInputEl.style.display = 'block';
                        }
                    }
                });
                xhr.addEventListener('error', (e) => {
                    statusMessage.textContent = t('ota.states.error') + (e.message ? ': ' + e.message : '');
                    statusMessage.style.color = '#f87171';
                    uploadBtn.disabled = false;
                    uploadBtn.style.display = 'inline-block';
                    if (fileInputEl) {
                        fileInputEl.disabled = false;
                        fileInputEl.style.display = 'block';
                    }
                });
                xhr.open('POST', API_BASE + '/api/ota/upload');
                xhr.send(file);
            } catch (e) {
                console.error('Erreur:', e);
                statusMessage.textContent = t('ota.error') + ': ' + e.message;
                statusMessage.style.color = '#E82127';
                uploadBtn.disabled = false;
                uploadBtn.style.display = 'inline-block';
                if (fileInputEl) {
                    fileInputEl.disabled = false;
                    fileInputEl.style.display = 'block';
            }
            }
        }
        async function restartDevice() {
            if (!confirm(t('ota.confirmRestart'))) {
                return;
            }
            try {
                await fetch(API_BASE + '/api/ota/restart', { method: 'POST' });
                const restartMessage = t('ota.restarting');
                const otaStatusEl = document.getElementById('ota-status-message');
                if (otaStatusEl) {
                    otaStatusEl.textContent = restartMessage;
                }
                const configNotificationEl = document.getElementById('config-notification');
                if (configNotificationEl) {
                    showNotification('config-notification', restartMessage, 'info', 10000);
                }
                setTimeout(() => {
                    location.reload();
                }, 10000);
            } catch (e) {
                console.error('Erreur:', e);
            }
        }
        // Simulation des événements CAN
        async function simulateEvent(eventType) {
            try {
                showNotification('simulation-notification', t('simulation.sending') + ': ' + getEventName(eventType) + '...', 'info');
                const response = await fetch(API_BASE + '/api/simulate/event', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event: eventType })
                });
                const result = await response.json();
                if (result.status === 'ok') {
                    showNotification('simulation-notification', 'OK - ' + t('simulation.simulated') + ': ' + getEventName(eventType), 'success');
                } else {
                    showNotification('simulation-notification', 'Error - ' + t('simulation.error'), 'error');
                }
            } catch (e) {
                console.error('Erreur:', e);
                showNotification('simulation-notification', 'Error - ' + t('simulation.error'), 'error');
            }
        }
        // Arrêter l'effet en cours
        async function stopEffect() {
            try {
                await fetch(API_BASE + '/api/effect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        effect: 0,
                        brightness: 0,
                        speed: 0,
                        color1: 0,
                        color2: 0,
                        color3: 0
                    })
                });
                showNotification('simulation-notification', 'Stop - ' + t('simulation.stopped'), 'success');
            } catch (e) {
                console.error('Erreur:', e);
                showNotification('simulation-notification', 'Error - ' + t('simulation.error'), 'error');
            }
        }
        // Toggle event on/off
        async function toggleEvent(eventType, isEnabled) {
            try {
                if (isEnabled) {
                    try {
                        await ensureEventsConfigData();
                    } catch (error) {
                        console.error('Failed to refresh events config for simulation:', error);
                    }
                    if (!isSimulationEventEnabled(eventType)) {
                        const checkbox = document.getElementById('toggle-' + eventType);
                        if (checkbox) {
                            checkbox.checked = false;
                        }
                        setToggleContainerState(eventType, false);
                        simulationTogglesState[eventType] = false;
                        showNotification('simulation-notification', t('simulation.disabledEvent'), 'error');
                        return;
                    }
                    cancelSimulationAutoStop(eventType);
                    setToggleContainerState(eventType, true);
                    showNotification('simulation-notification', t('simulation.sending') + ': ' + getEventName(eventType) + '...', 'info');
                    const response = await fetch(API_BASE + '/api/simulate/event', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ event: eventType })
                    });
                    const result = await response.json();
                    if (result.status === 'ok') {
                        showNotification('simulation-notification', 'OK - ' + getEventName(eventType) + ' ' + t('simulation.active'), 'success');
                        simulationTogglesState[eventType] = true;
                        const durationMs = await getSimulationEventDuration(eventType);
                        if (durationMs > 0) {
                            scheduleSimulationAutoStop(eventType, durationMs);
                        }
                    } else {
                        document.getElementById('toggle-' + eventType).checked = false;
                        setToggleContainerState(eventType, false);
                        showNotification('simulation-notification', 'Error - ' + t('simulation.error'), 'error');
                        simulationTogglesState[eventType] = false;
                    }
                } else {
                    cancelSimulationAutoStop(eventType);
                    showNotification('simulation-notification', t('simulation.stopping') + ': ' + getEventName(eventType) + '...', 'info');
                    const response = await fetch(API_BASE + '/api/stop/event', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ event: eventType })
                    });
                    const result = await response.json();
                    if (result.status === 'ok') {
                        setToggleContainerState(eventType, false);
                        showNotification('simulation-notification', 'Stop - ' + getEventName(eventType) + ' ' + t('simulation.stopped'), 'success');
                        simulationTogglesState[eventType] = false;
                        cancelSimulationAutoStop(eventType);
                    } else {
                        document.getElementById('toggle-' + eventType).checked = true;
                        setToggleContainerState(eventType, true);
                        showNotification('simulation-notification', 'Error - ' + t('simulation.error'), 'error');
                        simulationTogglesState[eventType] = true;
                    }
                }
            } catch (e) {
                console.error('Erreur:', e);
                document.getElementById('toggle-' + eventType).checked = true;
                setToggleContainerState(eventType, true);
                showNotification('simulation-notification', 'Error - ' + t('simulation.error'), 'error');
            }
        }
        // Toggle night mode simulation (single switch for ON/OFF)
        async function toggleNightMode(isEnabled) {
            const toggleContainer = document.getElementById('event-toggle-nightmode');
            const eventType = isEnabled ? 'NIGHT_MODE_ON' : 'NIGHT_MODE_OFF';
            const eventName = isEnabled ? t('canEvents.nightModeOn') : t('canEvents.nightModeOff');
            try {
                showNotification('simulation-notification', t('simulation.sending') + ': ' + eventName + '...', 'info');
                const response = await fetch(API_BASE + '/api/simulate/event', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event: eventType })
                });
                const result = await response.json();
                if (result.status === 'ok') {
                    toggleContainer.classList.toggle('active', isEnabled);
                    showNotification('simulation-notification', 'OK - ' + eventName, 'success');
                    simulationTogglesState['nightmode'] = isEnabled;
                } else {
                    document.getElementById('toggle-nightmode').checked = !isEnabled;
                    simulationTogglesState['nightmode'] = !isEnabled;
                    showNotification('simulation-notification', 'Error - ' + t('simulation.error'), 'error');
                }
            } catch (e) {
                console.error('Erreur:', e);
                document.getElementById('toggle-nightmode').checked = !isEnabled;
                simulationTogglesState['nightmode'] = !isEnabled;
                showNotification('simulation-notification', 'Error - ' + t('simulation.error'), 'error');
            }
        }
        function translateEventId(eventId) {
            if (!eventId) return null;
            const map = translations[currentLang] && translations[currentLang].eventNames;
            if (map && map[eventId]) {
                return map[eventId];
            }
            return null;
        }
        function translateEffectId(effectId) {
            if (!effectId) return null;
            const map = translations[currentLang] && translations[currentLang].effectNames;
            if (map && map[effectId]) {
                return map[effectId];
            }
            return null;
        }
        // Helper pour obtenir le nom d'un événement (depuis API uniquement)
        function getEventName(eventId) {
            const translated = translateEventId(typeof eventId === 'string' ? eventId : String(eventId));
            if (translated) {
                return translated;
            }
            if (eventTypesList.length > 0) {
                const stringId = typeof eventId === 'string' ? eventId : String(eventId);
                const eventById = eventTypesList.find(e => e.id === stringId);
                if (eventById) {
                    return eventById.name;
                }
                const numericIndex = typeof eventId === 'number' ? eventId : parseInt(eventId, 10);
                if (!Number.isNaN(numericIndex) && eventTypesList[numericIndex]) {
                    return eventTypesList[numericIndex].name;
                }
            }
            return `Event ${eventId}`;
        }
        // Helper pour obtenir le nom d'un effet (depuis API uniquement)
        function getEffectName(effectId) {
            const translated = translateEffectId(effectId);
            if (translated) {
                return translated;
            }
            if (effectsList.length > 0) {
                const effect = effectsList.find(e => e.id === effectId);
                return effect ? translateEffectId(effect.id) || effect.name : `Effect ${effectId}`;
            }
            return `Effect ${effectId}`;
        }
        // Charger la liste des effets depuis l'API
        let effectsList = [];
        // Helper: Convertir enum numérique en ID string
        function effectEnumToId(enumValue) {
            if (effectsList[enumValue]) {
                return effectsList[enumValue].id;
            }
            return effectsList[0]?.id || 'OFF';
        }
        // Helper: Convertir ID string en enum numérique
        function effectIdToEnum(id) {
            const index = effectsList.findIndex(e => e.id === id);
            return index >= 0 ? index : 0;
        }
        async function loadEffects() {
            try {
                const response = await fetch('/api/effects');
                const data = await response.json();
                effectsList = data.effects;
                // Mettre à jour tous les dropdowns d'effets
                const effectSelects = [
                    document.getElementById('default-effect-select'),
                    document.getElementById('effect-select'),
                    document.getElementById('event-effect-select')
                ];
                effectSelects.forEach(select => {
                    if (select) {
                        select.setAttribute('data-effect-options', 'true');
                        const currentValue = select.value;
                        select.innerHTML = '';
                        // Pour les sélecteurs d'effet par défaut et d'effet manuel,
                        // filtrer les effets qui nécessitent le CAN bus
                        const isEventSelector = select.id === 'event-effect-select';
                        effectsList.forEach(effect => {
                            // Filtrer les effets CAN si ce n'est pas le sélecteur d'événement
                            if (!isEventSelector && effect.can_required) {
                                return; // Skip cet effet
                            }
                            const option = document.createElement('option');
                            option.value = effect.id;
                            option.textContent = translateEffectId(effect.id) || effect.name;
                            option.setAttribute('data-effect-name', effect.name);
                            select.appendChild(option);
                        });
                        // Restaurer la valeur sélectionnée si elle existe encore
                        if (currentValue !== undefined && currentValue !== '') {
                            select.value = currentValue;
                        }
                    }
                });
                refreshEffectOptionLabels();
                console.log('Loaded', effectsList.length, 'effects from API');
            } catch (error) {
                console.error('Failed to load effects:', error);
            }
        }
        // Charger la liste des types d'événements depuis l'API
        let eventTypesList = [];
        async function loadEventTypes() {
            try {
                const response = await fetch('/api/event-types');
                const data = await response.json();
                eventTypesList = data.event_types;
                console.log('Loaded', eventTypesList.length, 'event types from API');
            } catch (error) {
                console.error('Failed to load event types:', error);
            }
        }
        async function loadInitialData() {
            await Promise.all([
                loadEffects(),
                loadEventTypes(),
                ensureEventsConfigData().catch(() => null)
            ]);
            renderSimulationSections();
            loadProfiles();
            loadConfig();
            updateStatus();
            loadOTAInfo();
            if (!statusIntervalHandle) {
                statusIntervalHandle = setInterval(updateStatus, 2000);
            }
        }
        // Init
        renderSimulationSections();
        applyTranslations();
        applyTheme();
        updateLanguageSelector();
        scheduleInitialDataLoad();
    </script>
</body>
</html>






