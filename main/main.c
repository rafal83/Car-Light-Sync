/**
 * @file main.c
 * @brief Main entry point for the Car Light Sync firmware
 *
 * Handles:
 * - Initialization of all subsystems (WiFi, SPIFFS, CAN, LED, Audio, BLE)
 * - Main LED render task (60 FPS)
 * - Detection and processing of CAN events
 * - Automatic night mode based on time
 * - Reset button handling for factory restore
 * - Boot loop protection (LP SRAM)
 */

#include "audio_input.h"
#include "ble_api_service.h"
#include "boot_loop_guard.h"
#include "can_bus.h"
#include "canserver_udp_server.h" // Optional CANServer UDP service
#include "captive_portal.h"
#include "config.h"
#include "config_manager.h"
#include "esp_log.h"
#include "esp_system.h"
#include "espnow_link.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "gvret_tcp_server.h" // Optional GVRET TCP service
#include "led_effects.h"
#include "led_strip_encoder.h"
#include "log_stream.h"
#include "nvs_flash.h"
#include "ota_update.h"
#include "reset_button.h"
#include "sdkconfig.h"
#include "settings_manager.h"
#include "spiffs_storage.h"
#include "status_led.h"
#include "status_manager.h"
#include "task_core_utils.h"
#include "vehicle_can_mapping.h"
#include "vehicle_can_unified.h"
#include "version_info.h"
#include "web_server.h"
#include "wifi_credentials.h" // Optional WiFi configuration
#include "wifi_manager.h"

#include <stddef.h>
#include <stdio.h>
#include <string.h>

// Configuration generated by generate_vehicle_can_config.py
#include "vehicle_can_unified_config.h"

#ifdef CONFIG_HAS_PSRAM
#include "cJSON.h"
#include "esp_heap_caps.h"
#endif

#define TAG_MAIN "Main"
#define BLE_VEHICLE_STATE_TYPE_CONFIG 0u
#define BLE_VEHICLE_STATE_TYPE_PARK 1u
#define BLE_VEHICLE_STATE_TYPE_DRIVE 2u
#define BLE_VEHICLE_STATE_HEADER(type, opts) ((uint8_t)((((type) & 0x07u) << 5) | ((opts) & 0x1Fu)))

static vehicle_state_t last_vehicle_state = {0};
static void espnow_test_frame_log(void);
static bool config_sended = false;
static vehicle_state_ble_config_t last_ble_config = {0};
static bool last_ble_config_valid = false;

// Callback for scroll wheel events (called from vehicle_state_apply_signal)
static void on_wheel_scroll_event(float scroll_value, const vehicle_state_t *state) {
  // Global opt-in
  if (!config_manager_get_wheel_control_enabled()) {
    return;
  }

  // Block if autopilot/cruise control is not fully disabled
  if (state->autopilot != 0 || state->cruise != 0) {
    return;
  }

  // Block above the configured speed threshold
  if (state->speed_kph > config_manager_get_wheel_control_speed_limit()) {
    return;
  }

  // scroll_value > 0 = scroll up, scroll_value < 0 = scroll down
  if (scroll_value > 0) {
    config_manager_cycle_active_profile(+1);
  } else if (scroll_value < 0) {
    config_manager_cycle_active_profile(-1);
  }
}

// Callback for CAN frames (both buses)
static void vehicle_can_callback(const can_frame_t *frame, can_bus_type_t bus_type, void *user_data) {
  vehicle_can_process_frame_static(frame, &last_vehicle_state);
  led_effects_update_vehicle_state(&last_vehicle_state);
  web_server_update_vehicle_state(&last_vehicle_state);
}

// Callback for ESP-NOW frames received on slave side: reuse the existing CAN pipeline
static void espnow_vehicle_state_rx_handler(const vehicle_state_t *state) {
  if (!state) {
    return;
  }
  // Update the shared state with a local timestamp (ticks) for frontend timeouts
  memcpy(&last_vehicle_state, state, sizeof(vehicle_state_t));
  last_vehicle_state.last_update_ms = xTaskGetTickCount();
  led_effects_update_vehicle_state(&last_vehicle_state);
  web_server_update_vehicle_state(&last_vehicle_state);
}

static void espnow_test_frame_log(void) {
  ESP_LOGI(TAG_MAIN, "ESP-NOW: test frame received (DE AD BE EF)");
}

// LED update task
static void led_task(void *pvParameters) {
  ESP_LOGI(TAG_MAIN, "LED task started");

  while (1) {
    // Render event overlays first so led_effects_update can skip/allow base effect correctly.
    config_manager_update();       // Handle temporary effects
    led_effects_update();
    vTaskDelay(pdMS_TO_TICKS(20)); // 50 FPS
  }
}

// Macro to reduce code duplication for event detection
#define CHECK_BOOLEAN_EVENT(field, on_event, off_event) \
  do { \
    if (prev->field != curr->field) { \
      if (curr->field) { \
        config_manager_process_can_event(on_event); \
      } else { \
        config_manager_stop_event(off_event); \
      } \
    } \
  } while (0)

#define CHECK_BOOLEAN_EVENT_NO_OFF(field, on_event) \
  do { \
    if (prev->field != curr->field) { \
      if (curr->field) { \
        config_manager_process_can_event(on_event); \
      } else { \
        config_manager_stop_event(on_event); \
      } \
    } \
  } while (0)

// CAN event processing task
static void can_event_task(void *pvParameters) {
  ESP_LOGI(TAG_MAIN, "CAN events task started");

  // Use double buffer with pointer swapping to avoid memcpy
  static vehicle_state_t state_buffer_a = {0};
  static vehicle_state_t state_buffer_b = {0};
  vehicle_state_t *curr = &state_buffer_a;
  vehicle_state_t *prev = &state_buffer_b;

  // Counter for periodic BLE dashboard updates (send every 200ms = 4 iterations)
  uint8_t ble_send_counter = 0;
  TickType_t last_state_send_ticks = 0;
  TickType_t last_config_send_ticks = 0;
  const TickType_t min_state_send_period = pdMS_TO_TICKS(50);
  const TickType_t config_send_period = pdMS_TO_TICKS(2000);

  while (1) {
    // Copy current state (still needed once to get latest data)
    memcpy(curr, &last_vehicle_state, sizeof(vehicle_state_t));

    // Note: handle_wheel_profile_control is called directly in vehicle_can_callback
    // to avoid missing scroll events that bounce quickly back to 0

    // Detect state changes and generate events
    // Turn signals - IMPORTANT: separate if blocks to detect each change independently

    CHECK_BOOLEAN_EVENT_NO_OFF(hazard, CAN_EVENT_TURN_HAZARD);
    CHECK_BOOLEAN_EVENT_NO_OFF(turn_left, CAN_EVENT_TURN_LEFT);
    CHECK_BOOLEAN_EVENT_NO_OFF(turn_right, CAN_EVENT_TURN_RIGHT);

    // Doors
    bool doors_open_left_now    = curr->door_front_left_open + curr->door_rear_left_open > 0;
    bool doors_open_left_before = prev->door_front_left_open + prev->door_rear_left_open > 0;
    bool doors_open_right_now   = curr->door_front_right_open + curr->door_rear_right_open > 0;
    bool doors_open_right_before = prev->door_front_right_open + prev->door_rear_right_open > 0;

    if (doors_open_left_now != doors_open_left_before) {
      if (doors_open_left_now) {
        config_manager_process_can_event(CAN_EVENT_DOOR_OPEN_LEFT);
        config_manager_stop_event(CAN_EVENT_DOOR_CLOSE_LEFT);
      } else {
        config_manager_process_can_event(CAN_EVENT_DOOR_CLOSE_LEFT);
        config_manager_stop_event(CAN_EVENT_DOOR_OPEN_LEFT);
      }
    }
    if (doors_open_right_now != doors_open_right_before) {
      if (doors_open_right_now) {
        config_manager_process_can_event(CAN_EVENT_DOOR_OPEN_RIGHT);
        config_manager_stop_event(CAN_EVENT_DOOR_CLOSE_RIGHT);
      } else {
        config_manager_process_can_event(CAN_EVENT_DOOR_CLOSE_RIGHT);
        config_manager_stop_event(CAN_EVENT_DOOR_OPEN_RIGHT);
      }
    }

    // Locking
    if (curr->locked != prev->locked) {
      if (curr->locked) {
        config_manager_process_can_event(CAN_EVENT_LOCKED);
        config_manager_stop_event(CAN_EVENT_UNLOCKED);
      } else {
        config_manager_process_can_event(CAN_EVENT_UNLOCKED);
        config_manager_stop_event(CAN_EVENT_LOCKED);
      }
    }

    // Transmission
    if (curr->gear != prev->gear) {
      if (curr->gear == 1) {
        config_manager_process_can_event(CAN_EVENT_GEAR_PARK);
        config_manager_stop_event(CAN_EVENT_GEAR_REVERSE);
        config_manager_stop_event(CAN_EVENT_GEAR_DRIVE);
      } else if (curr->gear == 2) {
        config_manager_process_can_event(CAN_EVENT_GEAR_REVERSE);
        config_manager_stop_event(CAN_EVENT_GEAR_PARK);
        config_manager_stop_event(CAN_EVENT_GEAR_DRIVE);
      } else if (curr->gear == 3) {
      } else if (curr->gear == 4) {
        config_manager_process_can_event(CAN_EVENT_GEAR_DRIVE);
        config_manager_stop_event(CAN_EVENT_GEAR_PARK);
        config_manager_stop_event(CAN_EVENT_GEAR_REVERSE);
      }
    }

    // Brakes
    CHECK_BOOLEAN_EVENT_NO_OFF(brake_pressed, CAN_EVENT_BRAKE_ON);

    // Blindspot - use macros to reduce duplication
    CHECK_BOOLEAN_EVENT_NO_OFF(blindspot_left, CAN_EVENT_BLINDSPOT_LEFT);
    CHECK_BOOLEAN_EVENT_NO_OFF(blindspot_right, CAN_EVENT_BLINDSPOT_RIGHT);
    CHECK_BOOLEAN_EVENT_NO_OFF(blindspot_left_alert, CAN_EVENT_BLINDSPOT_LEFT_ALERT);
    CHECK_BOOLEAN_EVENT_NO_OFF(blindspot_right_alert, CAN_EVENT_BLINDSPOT_RIGHT_ALERT);

    // Side collision
    CHECK_BOOLEAN_EVENT_NO_OFF(side_collision_left, CAN_EVENT_SIDE_COLLISION_LEFT);
    CHECK_BOOLEAN_EVENT_NO_OFF(side_collision_right, CAN_EVENT_SIDE_COLLISION_RIGHT);
    CHECK_BOOLEAN_EVENT_NO_OFF(forward_collision, CAN_EVENT_FORWARD_COLLISION);

    // Lane departure
    CHECK_BOOLEAN_EVENT_NO_OFF(lane_departure_left_lv1, CAN_EVENT_LANE_DEPARTURE_LEFT_LV1);
    CHECK_BOOLEAN_EVENT_NO_OFF(lane_departure_left_lv2, CAN_EVENT_LANE_DEPARTURE_LEFT_LV2);
    CHECK_BOOLEAN_EVENT_NO_OFF(lane_departure_right_lv1, CAN_EVENT_LANE_DEPARTURE_RIGHT_LV1);
    CHECK_BOOLEAN_EVENT_NO_OFF(lane_departure_right_lv2, CAN_EVENT_LANE_DEPARTURE_RIGHT_LV2);

    if (curr->sentry_mode != prev->sentry_mode) {
      if (curr->sentry_mode) {
        config_manager_process_can_event(CAN_EVENT_SENTRY_MODE_ON);
      } else {
        config_manager_stop_event(CAN_EVENT_SENTRY_MODE_OFF);
      }
    }

    CHECK_BOOLEAN_EVENT_NO_OFF(sentry_alert, CAN_EVENT_SENTRY_ALERT);

    // Autopilot
    // 0 "DISABLED"
    // 1 "UNAVAILABLE"
    // 2 "AVAILABLE"
    // 3 "ACTIVE_NOMINAL"
    // 4 "ACTIVE_RESTRICTED"
    // 5 "ACTIVE_NAV"
    // 8 "ABORTING"
    // 9 "ABORTED"
    // 14 "FAULT"
    // 15 "SNA"
    if (curr->autopilot != prev->autopilot) {
      if (curr->autopilot >= 3 && curr->autopilot <= 5) {
        config_manager_process_can_event(CAN_EVENT_AUTOPILOT_ENGAGED);
        config_manager_stop_event(CAN_EVENT_AUTOPILOT_DISENGAGED);
      } else if (curr->autopilot == 9) {
        config_manager_process_can_event(CAN_EVENT_AUTOPILOT_DISENGAGED);
        config_manager_stop_event(CAN_EVENT_AUTOPILOT_ENGAGED);
      }
    }

    CHECK_BOOLEAN_EVENT_NO_OFF(autopilot_alert_lv1, CAN_EVENT_AUTOPILOT_ALERT_LV1);
    CHECK_BOOLEAN_EVENT_NO_OFF(autopilot_alert_lv2, CAN_EVENT_AUTOPILOT_ALERT_LV2);

    // Charging
    CHECK_BOOLEAN_EVENT_NO_OFF(charging, CAN_EVENT_CHARGING);

    if (curr->charging_cable != prev->charging_cable) {
      if (curr->charging_cable) {
        config_manager_process_can_event(CAN_EVENT_CHARGING_CABLE_CONNECTED);
        config_manager_stop_event(CAN_EVENT_CHARGING_CABLE_DISCONNECTED);
      } else {
        config_manager_process_can_event(CAN_EVENT_CHARGING_CABLE_DISCONNECTED);
        config_manager_stop_event(CAN_EVENT_CHARGING_CABLE_CONNECTED);
      }
    }
    CHECK_BOOLEAN_EVENT_NO_OFF(charging_port, CAN_EVENT_CHARGING_PORT_OPENED);

    if (curr->charge_status != prev->charge_status) {
      if (curr->charge_status == 3) {
        // config_manager_process_can_event(CAN_EVENT_CHARGING);
      } else if (curr->charge_status == 4) {
        config_manager_process_can_event(CAN_EVENT_CHARGE_COMPLETE);
      } else if (curr->charge_status == 5) {
        config_manager_process_can_event(CAN_EVENT_CHARGING_STARTED);
      } else if (curr->charge_status == 1) {
        config_manager_process_can_event(CAN_EVENT_CHARGING_STOPPED);
      } else {
        config_manager_stop_event(CAN_EVENT_CHARGING);
        config_manager_stop_event(CAN_EVENT_CHARGE_COMPLETE);
        config_manager_stop_event(CAN_EVENT_CHARGING_STARTED);
        config_manager_stop_event(CAN_EVENT_CHARGING_STOPPED);
      }
    }

    // Speed threshold
    if (curr->speed_kph != prev->speed_kph || curr->speed_limit != prev->speed_limit) {
      if (curr->speed_kph > curr->speed_limit) {
        config_manager_process_can_event(CAN_EVENT_SPEED_THRESHOLD);
      } else {
        config_manager_stop_event(CAN_EVENT_SPEED_THRESHOLD);
      }
    }

    // Swap buffers instead of memcpy (much faster!)
    vehicle_state_t *temp = prev;
    prev = curr;
    curr = temp;

    // // Periodic BLE dashboard updates (every 200ms)
    // ble_send_counter++;
    // if (ble_send_counter >= 1) {  // 4 iterations * 50ms = 200ms
    //   ble_send_counter = 0;

      // Send current vehicle state to BLE dashboard if connected
      // Use mode-specific packet format based on gear (Drive vs Park)
      if (ble_api_service_is_connected()) {
        // Determine mode based on gear: P=1, R=2, N=3, D=4 (use prev since we swapped)
        bool is_drive_mode = (prev->gear == 2 || prev->gear == 3 || prev->gear == 4);

        vehicle_state_ble_config_t ble_config_state;
        memset(&ble_config_state, 0, sizeof(ble_config_state));
        vehicle_state_to_ble_config(prev, &ble_config_state);
        size_t config_compare_size = offsetof(vehicle_state_ble_config_t, last_update_ms);
        TickType_t now_ticks = xTaskGetTickCount();
        bool config_ack = ble_api_service_config_ack_received();
        bool config_changed = !last_ble_config_valid ||
                              (memcmp(&ble_config_state, &last_ble_config, config_compare_size) != 0);
        if (config_changed) {
          ble_api_service_clear_config_ack();
          config_ack = false;
        }
        bool config_due = !config_ack && (now_ticks - last_config_send_ticks) >= config_send_period;
        if (!config_sended || config_changed || config_due) {
          // Send CONFIG mode packet 
          static uint8_t ble_config_packet[1 + sizeof(vehicle_state_ble_config_t)];
          ble_config_packet[0] = BLE_VEHICLE_STATE_HEADER(BLE_VEHICLE_STATE_TYPE_CONFIG, 0);
          memcpy(ble_config_packet + 1, &ble_config_state, sizeof(vehicle_state_ble_config_t));
          esp_err_t ret = ble_api_service_send_vehicle_state(ble_config_packet, sizeof(ble_config_packet));
          if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
            ESP_LOGD(TAG_MAIN, "BLE config send failed: %s", esp_err_to_name(ret));
          }
          config_sended = true;
          if (ret == ESP_OK) {
            last_ble_config = ble_config_state;
            last_ble_config_valid = true;
            last_config_send_ticks = now_ticks;
          }
        }

        if (is_drive_mode) {
          // Send DRIVE mode packet (smaller, focused on driving metrics)
          static vehicle_state_ble_drive_t ble_drive_state;
          vehicle_state_to_ble_drive(prev, &ble_drive_state);
          static uint8_t ble_drive_packet[1 + sizeof(vehicle_state_ble_drive_t)];
          ble_drive_packet[0] = BLE_VEHICLE_STATE_HEADER(BLE_VEHICLE_STATE_TYPE_DRIVE, 0);
          memcpy(ble_drive_packet + 1, &ble_drive_state, sizeof(vehicle_state_ble_drive_t));
          esp_err_t ret = ble_api_service_send_vehicle_state(ble_drive_packet, sizeof(ble_drive_packet));
          if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
            ESP_LOGD(TAG_MAIN, "BLE drive mode send failed: %s", esp_err_to_name(ret));
          }
        } else {
          // Send PARK mode packet (focused on battery, charging, doors)
          static vehicle_state_ble_park_t ble_park_state;
          vehicle_state_to_ble_park(prev, &ble_park_state);
          static uint8_t ble_park_packet[1 + sizeof(vehicle_state_ble_park_t)];
          ble_park_packet[0] = BLE_VEHICLE_STATE_HEADER(BLE_VEHICLE_STATE_TYPE_PARK, 0);
          memcpy(ble_park_packet + 1, &ble_park_state, sizeof(vehicle_state_ble_park_t));
          esp_err_t ret = ble_api_service_send_vehicle_state(ble_park_packet, sizeof(ble_park_packet));
          if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
            ESP_LOGD(TAG_MAIN, "BLE park mode send failed: %s", esp_err_to_name(ret));
          }
        }
      } else {
        config_sended = false;
      }
    // }

    TickType_t now = xTaskGetTickCount();
    if (vehicle_can_state_dirty_get() && (now - last_state_send_ticks) >= min_state_send_period) {
      vehicle_can_state_dirty_clear();
      espnow_link_send_vehicle_state(prev); // Use prev since we swapped
      last_state_send_ticks = now;
    }

    vTaskDelay(pdMS_TO_TICKS(25)); // Check every 50 ms
  }
}

// Internal helper to update the status LED based on activity
static void update_status_led_internal(void) {
  wifi_status_t wifi_status;
  wifi_manager_get_status(&wifi_status);

  can_bus_status_t can_body_status, can_chassis_status;
  can_bus_get_status(CAN_BUS_BODY, &can_body_status);
  can_bus_get_status(CAN_BUS_CHASSIS, &can_chassis_status);

  // Priority order (highest priority first)
  if (ble_api_service_is_connected()) {
    status_led_set_state(STATUS_LED_BLE_CONNECTED);
  } else if (can_body_status.running || can_body_status.running) {
    // CAN active (at least one bus)
    status_led_set_state(STATUS_LED_CAN_ACTIVE);
  } else if (wifi_status.sta_connected) {
    // WiFi connected in station mode
    status_led_set_state(STATUS_LED_WIFI_STATION);
  } else if (wifi_status.ap_started && wifi_status.connected_clients > 0) {
    // AP mode active (clients connected)
    status_led_set_state(STATUS_LED_WIFI_AP);
  } else {
    // Default idle mode (no connections)
    status_led_set_state(STATUS_LED_IDLE);
  }
}

// Public function to force an update (called from reset_button.c)
// Forces change even if the LED is in FACTORY_RESET mode
void status_manager_update_led_now(void) {
  update_status_led_internal();
}

// Monitoring task
static void monitor_task(void *pvParameters) {
  TickType_t last_print          = 0;
  TickType_t last_activity_check = 0;

  while (1) {
    TickType_t now = xTaskGetTickCount();

    // Update status LED every 5 seconds
    if (now - last_activity_check > pdMS_TO_TICKS(5000)) {
      // Do not change the LED if it is in FACTORY_RESET (reset in progress)
      if (status_led_get_state() != STATUS_LED_FACTORY_RESET) {
        update_status_led_internal();
      }
      last_activity_check = now;
    }

    // Print stats every 30 seconds
    if (now - last_print > pdMS_TO_TICKS(30000)) {
      wifi_status_t wifi_status;
      wifi_manager_get_status(&wifi_status);

      can_bus_status_t can_chassis_status, can_body_status;
      can_bus_get_status(CAN_BUS_CHASSIS, &can_chassis_status);
      can_bus_get_status(CAN_BUS_BODY, &can_body_status);
      espnow_role_t role             = espnow_link_get_role();
      espnow_slave_type_t slave_type = espnow_link_get_slave_type();

      ESP_LOGI(TAG_MAIN, "=== Status ===");
      ESP_LOGI(TAG_MAIN, "WiFi AP: %s (IP: %s, Clients: %d)", wifi_status.ap_started ? "Active" : "Inactive", wifi_status.ap_ip, wifi_status.connected_clients);

      if (wifi_status.sta_connected) {
        ESP_LOGI(TAG_MAIN, "WiFi STA: Connected to %s (IP: %s)", wifi_status.sta_ssid, wifi_status.sta_ip);
      }
      ESP_LOGI(TAG_MAIN, "ESPNow: role %s, type %s", espnow_link_role_to_str(role), espnow_link_slave_type_to_str(slave_type));

      if (role == ESP_NOW_ROLE_MASTER) {
        if (can_body_status.running) {
          ESP_LOGI(TAG_MAIN, "CAN BODY: RX=%lu, TX=%lu, Err=%lu", can_body_status.rx_count, can_body_status.tx_count, can_body_status.errors);
        } else {
          ESP_LOGI(TAG_MAIN, "CAN BODY: Disconnected");
        }

        if (can_chassis_status.running) {
          ESP_LOGI(TAG_MAIN, "CAN CHASSIS: RX=%lu, TX=%lu, Err=%lu", can_chassis_status.rx_count, can_chassis_status.tx_count, can_chassis_status.errors);
        } else {
          ESP_LOGI(TAG_MAIN, "CAN CHASSIS: Disconnected");
        }
      }

      ESP_LOGI(TAG_MAIN, "Free memory: %lu bytes", esp_get_free_heap_size());
#ifdef CONFIG_HAS_PSRAM
      ESP_LOGI(TAG_MAIN, "Free PSRAM: %d bytes", heap_caps_get_free_size(MALLOC_CAP_SPIRAM));
#endif
      ESP_LOGI(TAG_MAIN, "==============");

      last_print = now;
    }

    vTaskDelay(pdMS_TO_TICKS(5000));
  }
}

/**
 * Memory allocation strategy within the project
 * =============================================
 *
 * This project uses multiple allocation methods depending on context:
 *
 * 1. malloc() / free() - Internal RAM (SRAM)
 *    - USE: Configuration structures, temporary buffers
 *    - ADVANTAGES: Fast, accessible by all peripherals (RMT, SPI, etc.)
 *    - LIMITS: ~200-300KB available on ESP32-S3
 *    - EXAMPLES: config_profile_t, short JSON buffers
 *
 * 2. heap_caps_malloc(size, MALLOC_CAP_SPIRAM) - External PSRAM
 *    - USE: Large buffers, cJSON data (when CONFIG_HAS_PSRAM)
 *    - ADVANTAGES: ~8MB available, reduces pressure on SRAM
 *    - LIMITS: Slower, incompatible with DMA/RMT
 *    - EXAMPLES: BLE buffers, large HTTP responses
 *
 * 3. heap_caps_malloc(size, MALLOC_CAP_DEFAULT) - Default RAM
 *    - USE: Generic allocation compatible with BLE/WiFi
 *    - ADVANTAGES: Compatible with all contexts
 *    - LIMITS: Uses internal SRAM
 *    - EXAMPLES: Temporary BLE buffers
 *
 * CHOICE RULES:
 * - LED/RMT buffers: always malloc() (DMA incompatible with PSRAM)
 * - Config profiles: malloc() (frequent access, small size)
 * - JSON buffers > 4KB: heap_caps_malloc(PSRAM) when available
 * - BLE buffers: heap_caps_malloc(DEFAULT) for compatibility
 * - Temporary buffers < 1KB: stack (local variables)
 */

#ifdef CONFIG_HAS_PSRAM
// cJSON memory allocation functions using PSRAM
static void *psram_malloc(size_t size) {
  return heap_caps_malloc(size, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
}

static void psram_free(void *ptr) {
  heap_caps_free(ptr);
}
#endif

static const char *reset_reason_to_str(int reason) {
  switch (reason) {
  case ESP_RST_POWERON:
    return "POWERON";
  case ESP_RST_EXT:
    return "EXT";
  case ESP_RST_SW:
    return "SW";
  case ESP_RST_PANIC:
    return "PANIC";
  case ESP_RST_INT_WDT:
    return "INT_WDT";
  case ESP_RST_TASK_WDT:
    return "TASK_WDT";
  case ESP_RST_WDT:
    return "WDT";
  case ESP_RST_DEEPSLEEP:
    return "DEEPSLEEP";
  case ESP_RST_BROWNOUT:
    return "BROWNOUT";
  case ESP_RST_SDIO:
    return "SDIO";
  case ESP_RST_USB:
    return "USB";
  case ESP_RST_JTAG:
    return "JTAG";
  case ESP_RST_EFUSE:
    return "EFUSE";
  case ESP_RST_PWR_GLITCH:
    return "PWR_GLITCH";
  case ESP_RST_CPU_LOCKUP:
    return "CPU_LOCKUP";
  default:
    return "UNKNOWN";
  }
}

void app_main(void) {
// Temporarily disabled: cJSON uses regular RAM instead of PSRAM to avoid conflicts with the LED/RMT task
#ifdef CONFIG_HAS_PSRAM
  cJSON_Hooks hooks = {.malloc_fn = psram_malloc, .free_fn = psram_free};
  cJSON_InitHooks(&hooks);
#endif

  int reset_reason = (int)esp_reset_reason();
  ESP_LOGI(TAG_MAIN, "Reset reason: %s (%d)", reset_reason_to_str(reset_reason), reset_reason);

  // Default: master/none. SPIFFS can override via /api/espnow/config
  espnow_role_t default_role  = ESP_NOW_ROLE_MASTER;
  espnow_slave_type_t default_type = ESP_NOW_SLAVE_NONE;

  // Reduce log level for all ESP-IDF components
  esp_log_level_set("*", ESP_LOG_WARN);     // Default: warnings only
  esp_log_level_set("wifi", ESP_LOG_ERROR); // WiFi: errors only
  esp_log_level_set("esp_netif_handlers", ESP_LOG_ERROR);

  // Enable project logs
  esp_log_level_set(TAG_MAIN, ESP_LOG_INFO);
  esp_log_level_set(TAG_CAN_BUS, ESP_LOG_INFO);
  esp_log_level_set(TAG_CAN, ESP_LOG_INFO);
  esp_log_level_set(TAG_WIFI, ESP_LOG_INFO); // WiFi module logs
  esp_log_level_set(TAG_WEBSERVER, ESP_LOG_INFO);
  // esp_log_level_set(TAG_LED_ENCODER, ESP_LOG_INFO);
  esp_log_level_set(TAG_LED, ESP_LOG_INFO);
  esp_log_level_set(TAG_CONFIG, ESP_LOG_INFO);
  // esp_log_level_set(TAG_OTA, ESP_LOG_INFO);
  esp_log_level_set(TAG_AUDIO, ESP_LOG_INFO);
  esp_log_level_set(TAG_BLE_API, ESP_LOG_INFO);
  esp_log_level_set(TAG_ESP_NOW, ESP_LOG_INFO);

  ESP_LOGI(TAG_MAIN, "=================================");
  ESP_LOGI(TAG_MAIN, "        Car Light Sync           ");
  ESP_LOGI(TAG_MAIN, "       Version %s            ", APP_VERSION_STRING);
  ESP_LOGI(TAG_MAIN, "        Made in France \xF0\x9F\x87\xAB\xF0\x9F\x87\xB7");
  ESP_LOGI(TAG_MAIN, "=================================");

  // Initialize boot loop protection (LP SRAM)
  // IMPORTANT: Must be called before any other initialization
  ESP_ERROR_CHECK(boot_loop_guard_init());
  uint32_t boot_count = boot_loop_guard_get_count();
  if (boot_count > 1) {
    ESP_LOGW(TAG_MAIN, "Boot count: %lu (boot loop protection active)", boot_count);
  }

  // Initialize device names with MAC suffix
  config_init_device_names();
  ESP_LOGI(TAG_MAIN, "WiFi AP SSID: %s", g_wifi_ssid_with_suffix);
  ESP_LOGI(TAG_MAIN, "BLE Device Name: %s", g_device_name_with_suffix);

  // Initialize NVS (reduced to 16KB for WiFi/OTA only)
  esp_err_t ret = nvs_flash_init();
  if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
  }
  ESP_ERROR_CHECK(ret);
  ESP_LOGI(TAG_MAIN, "NVS initialized (16KB)");

  // Initialize SPIFFS (176KB for profiles/config)
  ESP_ERROR_CHECK(spiffs_storage_init());
  size_t spiffs_total = 0, spiffs_used = 0;
  if (spiffs_get_stats(&spiffs_total, &spiffs_used) == ESP_OK) {
    ESP_LOGI(TAG_MAIN, "SPIFFS initialized: %d KB total, %d KB used", spiffs_total / 1024, spiffs_used / 1024);
  }

  // Initialize system settings manager (SPIFFS/JSON)
  ESP_ERROR_CHECK(settings_manager_init());
  ESP_LOGI(TAG_MAIN, "Settings manager initialized");

  // Validate current OTA partition (after an update)
  ESP_ERROR_CHECK(ota_validate_current_partition());

  // Initialize OTA
  ESP_ERROR_CHECK(ota_init());
  ESP_LOGI(TAG_MAIN, "OTA initialized, version: %s", ota_get_current_version());

  // Initialize modules
  ESP_LOGI(TAG_MAIN, "Initializing modules...");

  uint8_t saved_role_u8 = settings_get_u8("espnow_role", (uint8_t)default_role);
  uint8_t saved_type_u8 = settings_get_u8("espnow_type", (uint8_t)default_type);

  espnow_role_t espnow_role       = (saved_role_u8 <= ESP_NOW_ROLE_SLAVE) ? (espnow_role_t)saved_role_u8 : default_role;
  espnow_slave_type_t espnow_type = (saved_type_u8 < ESP_NOW_SLAVE_MAX) ? (espnow_slave_type_t)saved_type_u8 : default_type;

  ESP_LOGI(TAG_MAIN, "ESPNow config: saved_role=%s saved_type=%s",
           espnow_link_role_to_str(espnow_role),
           espnow_link_slave_type_to_str(espnow_type));
  uint64_t hb = espnow_link_get_last_peer_heartbeat_us();
  ESP_LOGI(TAG_MAIN, "ESPNow initial heartbeat: %llu us", (unsigned long long)hb);

  // Status LED (integrated WS2812)
  esp_err_t status_led_err = status_led_init();
  if (status_led_err == ESP_OK) {
    ESP_LOGI(TAG_MAIN, "Status LED initialized");
    status_led_set_state(STATUS_LED_BOOT);
  } else if (status_led_err != ESP_ERR_NOT_SUPPORTED) {
    ESP_LOGW(TAG_MAIN, "Status LED init failed");
  }

  // Reset button
  esp_err_t reset_btn_err = reset_button_init();
  if (reset_btn_err == ESP_OK) {
    ESP_LOGI(TAG_MAIN, "Reset button initialized (GPIO 4, hold 5s = factory reset)");
  } else {
    ESP_LOGW(TAG_MAIN, "Reset button init failed");
  }

  // CAN: master only (ESP-NOW slaves do not have a CAN controller)
  if (espnow_role == ESP_NOW_ROLE_MASTER) {
    // CAN bus - Body
    ESP_ERROR_CHECK(can_bus_init(CAN_BUS_BODY, CAN_TX_BODY_PIN, CAN_RX_BODY_PIN));
    ESP_LOGI(TAG_MAIN, "CAN bus BODY initialized (GPIO TX=%d, RX=%d)", CAN_TX_BODY_PIN, CAN_RX_BODY_PIN);

    // CAN bus - Chassis
    ESP_ERROR_CHECK(can_bus_init(CAN_BUS_CHASSIS, CAN_TX_CHASSIS_PIN, CAN_RX_CHASSIS_PIN));
    ESP_LOGI(TAG_MAIN, "CAN bus CHASSIS initialized (GPIO TX=%d, RX=%d)", CAN_TX_CHASSIS_PIN, CAN_RX_CHASSIS_PIN);

    // Register shared callback for both buses
    ESP_ERROR_CHECK(can_bus_register_callback(vehicle_can_callback, NULL));

    // Register callback for scroll wheel events
    vehicle_can_set_wheel_scroll_callback(on_wheel_scroll_event);

    // Start both CAN buses
    ESP_ERROR_CHECK(can_bus_start(CAN_BUS_CHASSIS));
    ESP_ERROR_CHECK(can_bus_start(CAN_BUS_BODY));
    ESP_LOGI(TAG_MAIN, "Both CAN buses started");
  } else {
    ESP_LOGI(TAG_MAIN, "ESP-NOW slave mode: CAN disabled");
    espnow_link_register_test_rx_callback(espnow_test_frame_log);
    espnow_link_register_vehicle_state_rx_callback(espnow_vehicle_state_rx_handler);
  }

  // LEDs
  if (!led_effects_init()) {
    ESP_LOGE(TAG_MAIN, "LED initialization error");
    return;
  }
  ESP_LOGI(TAG_MAIN, "LEDs initialized");

  // Configuration manager
  if (!config_manager_init()) {
    ESP_LOGE(TAG_MAIN, "Configuration manager initialization error");
    return;
  }
  ESP_LOGI(TAG_MAIN, "Configuration manager initialized");

  if (espnow_role == ESP_NOW_ROLE_MASTER) {
    // Audio module (INMP441 mic)
    if (!audio_input_init()) {
      ESP_LOGW(TAG_MAIN, "Audio module unavailable (optional)");
    } else {
      ESP_LOGI(TAG_MAIN, "Audio module initialized");
      // Reapply the default effect to enable audio if needed (effect applied before audio init)
      config_manager_reapply_default_effect();
    }
  }

#if CONFIG_BT_ENABLED
  esp_err_t ble_init_status = ble_api_service_init();
  if (ble_init_status == ESP_OK) {
    esp_err_t ble_start_status = ble_api_service_start();
    if (ble_start_status != ESP_OK) {
      ESP_LOGW(TAG_MAIN, "Failed to start BLE service: %s", esp_err_to_name(ble_start_status));
    }
  } else {
    ESP_LOGW(TAG_MAIN, "BLE service unavailable: %s", esp_err_to_name(ble_init_status));
  }
#else
  ESP_LOGW(TAG_MAIN, "BLE disabled in configuration, Web Bluetooth unavailable");
#endif

  // Create tasks
  create_task_on_led_core(led_task, "led_task", 4096, NULL, 5, NULL);
  create_task_on_general_core(can_event_task, "can_event_task", 8192, NULL, 4,
                              NULL); // Increased to 8KB because of config_profile_t
  create_task_on_general_core(monitor_task, "monitor_task", 4096, NULL, 2, NULL);


  // Log streaming (Server-Sent Events for real-time logs)
  ESP_ERROR_CHECK(log_stream_init());
  esp_err_t log_file_ret = log_stream_enable_file_logging(true);
  if (log_file_ret != ESP_OK) {
    ESP_LOGW(TAG_MAIN, "Log file logging disabled (err=%s)", esp_err_to_name(log_file_ret));
  }
  ESP_LOGI(TAG_MAIN, "Log streaming initialized");
  
  // WiFi
  status_led_set_state(STATUS_LED_WIFI_CONNECTING);
  ESP_ERROR_CHECK(wifi_manager_init());
  ESP_ERROR_CHECK(captive_portal_init());
  ESP_ERROR_CHECK(wifi_manager_start_ap());

#ifdef WIFI_AUTO_CONNECT
  // Auto-connect to home WiFi if configured
  ESP_LOGI(TAG_MAIN, "Attempting to connect to %s...", WIFI_HOME_SSID);
  wifi_manager_connect_sta(WIFI_HOME_SSID, WIFI_HOME_PASSWORD);
  vTaskDelay(pdMS_TO_TICKS(5000)); // Wait 5s for connection
#endif

  ESP_LOGI(TAG_MAIN, "WiFi initialized");
  status_led_set_state(STATUS_LED_WIFI_AP);

  ESP_ERROR_CHECK(espnow_link_init(espnow_role, espnow_type));
  ESP_LOGI(TAG_MAIN, "ESPNow initialized");

  // Web server
  ESP_ERROR_CHECK(web_server_init());
  ESP_ERROR_CHECK(web_server_start());
  ESP_LOGI(TAG_MAIN, "Web server started");



  if (espnow_role == ESP_NOW_ROLE_MASTER) {
    // GVRET TCP server (initialized but not started - controlled via web interface)
    ESP_ERROR_CHECK(gvret_tcp_server_init());
    ESP_LOGI(TAG_MAIN, "GVRET TCP server initialized (port 23, enabled via web UI)");
    if (gvret_tcp_server_get_autostart()) {
      ESP_ERROR_CHECK(gvret_tcp_server_start());
      ESP_LOGI(TAG_MAIN, "  Auto-start enabled (GVRET)");
    }

    // CANServer UDP server (initialized but not started - controlled via web interface)
    ESP_ERROR_CHECK(canserver_udp_server_init());
    ESP_LOGI(TAG_MAIN, "CANServer UDP server initialized (port 1338, enabled via web UI)");
    if (canserver_udp_server_get_autostart()) {
      ESP_ERROR_CHECK(canserver_udp_server_start());
      ESP_LOGI(TAG_MAIN, "  Auto-start enabled (CANServer)");
    }
  }

  // Display connection information
  wifi_status_t wifi_status;
  wifi_manager_get_status(&wifi_status);

  ESP_LOGI(TAG_MAIN, "");
  ESP_LOGI(TAG_MAIN, "=================================");
  ESP_LOGI(TAG_MAIN, "  Web Interface Available");
  ESP_LOGI(TAG_MAIN, "  SSID: %s", g_wifi_ssid_with_suffix);
  ESP_LOGI(TAG_MAIN, "  Password: %s", WIFI_AP_PASSWORD);
  ESP_LOGI(TAG_MAIN, "  URL: http://%s", wifi_status.ap_ip);
  ESP_LOGI(TAG_MAIN, "=================================");
  ESP_LOGI(TAG_MAIN, "");

  ESP_LOGI(TAG_MAIN, "System started successfully!");

  // Mark boot as successful (resets boot loop counter)
  // Note: the internal watchdog will do this after ~30s, but we mark it now
  // because all critical components are initialized
  boot_loop_guard_mark_success();

  // Main function ends, FreeRTOS tasks keep running
  ESP_LOGI(TAG_MAIN, "app_main completed, tasks running");
  esp_log_level_set(TAG_MAIN, ESP_LOG_WARN);
}
