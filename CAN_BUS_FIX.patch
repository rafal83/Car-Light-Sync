--- can_bus.c.orig
+++ can_bus.c
@@ -108,8 +108,18 @@ esp_err_t can_bus_init(can_bus_type_t bus_type, int tx_gpio, int rx_gpio) {
   ctx->rx_task_handle = NULL;

   // Config générale : mode normal, pins
   twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(
       tx_gpio, rx_gpio, TWAI_MODE_LISTEN_ONLY);
+
+  // CRITIQUE: Activer les alertes pour détecter bus_off et erreurs
+  g_config.alerts_enabled = TWAI_ALERT_BUS_OFF |
+                            TWAI_ALERT_ERR_PASS |
+                            TWAI_ALERT_BUS_RECOVERED |
+                            TWAI_ALERT_ABOVE_ERR_WARN |
+                            TWAI_ALERT_ERR_ACTIVE;
+
+  // Permet la récupération automatique depuis bus_off
+  g_config.bus_off_io = 1;

   // Vitesse 500 kbit/s (Tesla)
   twai_timing_config_t t_config = TWAI_TIMING_CONFIG_500KBITS();

@@ -195,6 +205,9 @@ esp_err_t can_bus_start(can_bus_type_t bus_type) {

   ctx->running = true;

+  // Clear toutes les alertes au démarrage
+  uint32_t alerts_triggered;
+  twai_read_alerts(&alerts_triggered, 0);
+
   // Créer la tâche de réception
   if (ctx->rx_task_handle == NULL) {
     can_rx_task_params_t *params = malloc(sizeof(can_rx_task_params_t));

==== Nouvelle tâche de monitoring ====

Ajouter une tâche de monitoring des alertes TWAI :

static void can_alert_task(void *pvParameters) {
  can_bus_type_t bus_type = *((can_bus_type_t*)pvParameters);
  can_bus_context_t *ctx = &s_can_buses[bus_type];
  const char *bus_name = (bus_type == CAN_BUS_BODY) ? "BODY" : "CHASSIS";

  ESP_LOGI(TAG_CAN_BUS, "Tâche ALERT démarrée pour bus %s", bus_name);

  while (ctx->running) {
    uint32_t alerts;

#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 2, 0) && SOC_TWAI_CONTROLLER_NUM >= 2
    esp_err_t ret = twai_read_alerts_v2(ctx->bus_handle, &alerts, pdMS_TO_TICKS(1000));
#else
    esp_err_t ret = twai_read_alerts(&alerts, pdMS_TO_TICKS(1000));
#endif

    if (ret == ESP_OK) {
      if (alerts & TWAI_ALERT_BUS_OFF) {
        ESP_LOGW(TAG_CAN_BUS, "[%s] ⚠️  BUS_OFF détecté ! Tentative de récupération...", bus_name);
        ctx->errors++;

        // Initier la récupération
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 2, 0) && SOC_TWAI_CONTROLLER_NUM >= 2
        twai_initiate_recovery_v2(ctx->bus_handle);
#else
        twai_initiate_recovery();
#endif
      }

      if (alerts & TWAI_ALERT_ERR_PASS) {
        ESP_LOGW(TAG_CAN_BUS, "[%s] Mode ERROR_PASSIVE", bus_name);
      }

      if (alerts & TWAI_ALERT_BUS_RECOVERED) {
        ESP_LOGI(TAG_CAN_BUS, "[%s] ✓ Bus récupéré", bus_name);
      }

      if (alerts & TWAI_ALERT_ABOVE_ERR_WARN) {
        ESP_LOGW(TAG_CAN_BUS, "[%s] Compteur d'erreur > seuil", bus_name);
      }
    }
  }

  ESP_LOGI(TAG_CAN_BUS, "Tâche ALERT terminée pour bus %s", bus_name);
  vTaskDelete(NULL);
}

// Dans can_bus_start(), créer aussi la tâche d'alerte :

  char alert_task_name[20];
  snprintf(alert_task_name, sizeof(alert_task_name), "can_alert_%s", bus_name);

  can_bus_type_t *alert_params = malloc(sizeof(can_bus_type_t));
  *alert_params = bus_type;

  xTaskCreatePinnedToCore(can_alert_task, alert_task_name, 2048, alert_params, 9,
                          NULL, 0);
